import asyncio
import json
import yaml
import importlib.util
from pathlib import Path
import shutil
import time
from rich.console import Console
from rich.panel import Panel
from rich.syntax import Syntax
from rich.table import Table

console = Console()

def define_semantic_convention(temp_dir: Path) -> Path:
    """1. DEFINE: Create a mock semantic convention file."""
    console.print(Panel("[bold cyan]Step 1: Defining Semantic Convention[/bold cyan]", expand=False))
    
    semantic_content = {
        "groups": [
            {
                "id": "prototype.agent",
                "type": "attribute_group",
                "prefix": "proto.agent",
                "brief": "A prototype agent for the full cycle demo.",
                "attributes": [
                    {
                        "id": "role",
                        "type": "string",
                        "brief": "The role of the prototype agent.",
                        "examples": ["generator", "validator"]
                    }
                ]
            }
        ]
    }
    
    yaml_path = temp_dir / "prototype_semantic.yaml"
    with open(yaml_path, "w") as f:
        yaml.dump(semantic_content, f)
        
    console.print(f"  [green]âœ“[/green] Created mock semantic convention at [cyan]{yaml_path}[/cyan]")
    console.print(Syntax(yaml.dump(semantic_content), "yaml", theme="monokai", line_numbers=True))
    return yaml_path

def generate_code_from_convention(yaml_path: Path, temp_dir: Path) -> Path:
    """2. GENERATE: Create a Python agent file from the convention."""
    console.print(Panel("[bold cyan]Step 2: Generating Code from Convention[/bold cyan]", expand=False))
    
    with open(yaml_path, "r") as f:
        semantics = yaml.safe_load(f)
    
    agent_id = semantics["groups"][0]["id"]
    agent_role = semantics["groups"][0]["attributes"][0]["id"]

    # This simulates a template engine like Jinja2
    agent_code = f'''
# This file is dynamically generated by the full-cycle prototype
import time
from datetime import datetime

def run_agent():
    """Simulates the execution of a generated agent."""
    print(f"    [bright_magenta]â–¶ Executing generated agent: {agent_id}[/bright_magenta]")
    
    # Simulate doing some work
    time.sleep(0.5)
    
    # Generate a mock OpenTelemetry span as a dictionary
    span = {{
        "name": "agent.execution",
        "context": {{
            "trace_id": "trace-123",
            "span_id": "span-abc",
        }},
        "status": "SUCCESS",
        "attributes": {{
            "agent.id": "{agent_id}",
            "agent.role": "{agent_role}",
            "execution.timestamp": datetime.utcnow().isoformat(),
        }}
    }}
    
    print(f"    [bright_blue]âœ“ Agent {agent_id} finished, produced 1 span.[/bright_blue]")
    return [span]
'''

    agent_path = temp_dir / "generated_agent.py"
    with open(agent_path, "w") as f:
        f.write(agent_code)
        
    console.print(f"  [green]âœ“[/green] Generated agent code at [cyan]{agent_path}[/cyan]")
    console.print(Syntax(agent_code, "python", theme="monokai", line_numbers=True))
    return agent_path

def execute_generated_code(agent_path: Path) -> list:
    """3. EXECUTE: Dynamically import and run the generated agent."""
    console.print(Panel("[bold cyan]Step 3: Executing Generated Code[/bold cyan]", expand=False))
    
    try:
        spec = importlib.util.spec_from_file_location("generated_agent", agent_path)
        generated_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(generated_module)
        
        # Run the agent and capture its output (the spans)
        spans = generated_module.run_agent()
        return spans
    except Exception as e:
        console.print(f"  [red]âœ—[/red] Failed to execute generated code: {e}")
        return []

def validate_with_spans(spans: list) -> bool:
    """4. VALIDATE: Analyze the spans from the execution."""
    console.print(Panel("[bold cyan]Step 4: Validating Execution with Spans[/bold cyan]", expand=False))
    
    if not spans:
        console.print("  [red]âœ—[/red] No spans were generated, validation failed.")
        return False

    table = Table(title="Span Validation Report")
    table.add_column("Span Name", style="cyan")
    table.add_column("Status", style="green")
    table.add_column("Agent ID", style="yellow")
    table.add_column("Agent Role", style="magenta")

    all_successful = True
    for span in spans:
        status = span.get("status", "UNKNOWN")
        attributes = span.get("attributes", {})
        agent_id = attributes.get("agent.id", "N/A")
        agent_role = attributes.get("agent.role", "N/A")
        
        status_color = "green" if status == "SUCCESS" else "red"
        if status != "SUCCESS":
            all_successful = False
            
        table.add_row(
            span.get("name", "N/A"),
            f"[{status_color}]{status}[/{status_color}]",
            agent_id,
            agent_role
        )

    console.print(table)
    console.print("  [green]âœ“[/green] Span analysis complete.")
    return all_successful

async def main():
    """Orchestrates the full prototype cycle."""
    temp_dir = Path("./prototype_cycle_workspace")
    
    try:
        # Clean up previous runs
        if temp_dir.exists():
            shutil.rmtree(temp_dir)
        temp_dir.mkdir()

        console.print(Panel(
            "[bold green]ðŸš€ Starting Full Cycle Prototype[/bold green]\n"
            "This script demonstrates the Define -> Generate -> Execute -> Validate loop.",
            title="WeaverGen Full Cycle Demo",
            border_style="green"
        ))

        # Step 1: Define
        yaml_path = define_semantic_convention(temp_dir)
        time.sleep(1)

        # Step 2: Generate
        agent_path = generate_code_from_convention(yaml_path, temp_dir)
        time.sleep(1)

        # Step 3: Execute
        generated_spans = execute_generated_code(agent_path)
        time.sleep(1)

        # Step 4: Validate
        validation_passed = validate_with_spans(generated_spans)

        # Final Result
        console.print(Panel("[bold cyan]Final Result[/bold cyan]", expand=False))
        if validation_passed:
            console.print("  [bold green]âœ… Full cycle completed and validated successfully![/bold green]")
        else:
            console.print("  [bold red]âœ— Full cycle failed during validation.[/bold red]")

    finally:
        # Clean up the temporary directory
        if temp_dir.exists():
            shutil.rmtree(temp_dir)
        console.print(f"\n[dim]ðŸ§¹ Cleaned up temporary directory: {temp_dir}[/dim]")

if __name__ == "__main__":
    asyncio.run(main())
