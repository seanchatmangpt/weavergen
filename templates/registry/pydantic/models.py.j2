#!/usr/bin/env python3
"""
Pydantic models generated from semantic conventions.
Generated by Weaver Forge on {{ now() }}.
Source: {{ schema_url }}
"""

from typing import List, Dict, Optional, Any, Literal, Union
from datetime import datetime
from enum import Enum
from pydantic import BaseModel, Field

{%- macro python_type(attr) -%}
{%- if attr.type == "string" -%}
str
{%- elif attr.type == "int" -%}
int
{%- elif attr.type == "double" -%}
float
{%- elif attr.type == "boolean" -%}
bool
{%- elif attr.type == "string[]" -%}
List[str]
{%- elif attr.type == "template[string]" -%}
Dict[str, Any]
{%- elif attr.type.allow_custom_values is defined -%}
{%- if attr.type.members | length > 0 -%}
Literal[{{ attr.type.members | map(attribute='value') | map('tojson') | join(', ') }}]
{%- else -%}
str
{%- endif -%}
{%- else -%}
Any
{%- endif -%}
{%- endmacro -%}

{%- macro field_def(attr) -%}
{%- if attr.requirement_level == "required" -%}
Field(..., description="{{ attr.brief | replace('"', '\\"') }}")
{%- else -%}
Field(None, description="{{ attr.brief | replace('"', '\\"') }}")
{%- endif -%}
{%- endmacro -%}

{%- macro field_name(id) -%}
{{ id | replace(".", "_") | replace("-", "_") }}
{%- endmacro -%}

# Enums for constrained values
{% for group in groups %}
{%- for attr in group.attributes | default([]) %}
{%- if attr.type.members is defined and attr.type.allow_custom_values == false %}
class {{ (group.id ~ "_" ~ attr.id) | replace(".", "_") | replace("-", "_") | upper }}(str, Enum):
    """{{ attr.brief }}"""
    {%- for member in attr.type.members %}
    {{ member.id | upper }} = "{{ member.value }}"
    {%- endfor %}

{% endif -%}
{%- endfor %}
{%- endfor %}

# Generated models from semantic conventions
{% for group in groups %}
{%- if group.type == "span" or group.type == "attribute_group" %}
class {{ group.id | replace(".", "_") | replace("-", "_") | capitalize }}Model(BaseModel):
    """
    {{ group.brief }}
    
    Generated from: {{ group.id }}
    """
    {%- if group.extends %}
    # Inherits from: {{ group.extends }}
    {%- endif %}
    
    {%- for attr in group.attributes | default([]) %}
    {{ field_name(attr.id) }}: {% if attr.requirement_level == "required" %}{{ python_type(attr) }}{% else %}Optional[{{ python_type(attr) }}]{% endif %} = {{ field_def(attr) }}
    {%- endfor %}
    
    {%- if not group.attributes %}
    pass
    {%- endif %}

{% endif -%}
{%- endfor %}

# Special output models for Pydantic AI agents
{% for group in groups %}
{%- if group.id starts_with "agent.output" %}
class {{ group.id | replace("agent.output.", "") | capitalize }}Output(BaseModel):
    """Output model for {{ group.id }}"""
    {%- for attr in group.attributes | default([]) %}
    {%- if attr.type == "template[string]" %}
    # Note: {{ attr.id }} is a template type - implement based on use case
    {%- endif %}
    {%- endfor %}
    
    # Standard fields based on semantic convention
    {%- if group.id == "agent.output.decision" %}
    decision: str = Field(..., description="The decision made")
    reasoning: str = Field(..., description="Detailed reasoning")
    confidence: float = Field(..., ge=0.0, le=1.0, description="Confidence level")
    alternatives_considered: List[str] = Field(default_factory=list)
    next_steps: List[str] = Field(default_factory=list)
    {%- elif group.id == "agent.output.analysis" %}
    insights: List[str] = Field(..., description="Key insights discovered")
    patterns: List[Dict[str, Any]] = Field(default_factory=list)
    recommendations: List[str] = Field(..., description="Recommended actions")
    confidence: float = Field(..., ge=0.0, le=1.0)
    {%- elif group.id == "agent.output.motion" %}
    motion_text: str = Field(..., description="The formal motion text")
    motion_type: str = Field(..., description="Type of motion")
    requires_second: bool = Field(default=True)
    vote_threshold: str = Field(default="majority")
    {%- endif %}

{% endif -%}
{%- endfor %}