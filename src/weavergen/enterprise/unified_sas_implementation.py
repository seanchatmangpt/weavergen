#!/usr/bin/env python3
"""
Unified Scrum at Scale implementation building on the prototype patterns.
Uses the established trajectory:
1. Weaver-generated code from semantic conventions
2. Pydantic models for type safety
3. Integration layer bridging models to generated code
4. Pydantic AI agents with Ollama
5. Full OTel observability
"""

import sys
import os
import asyncio
from typing import List, Optional, Dict, Any, Literal
from dataclasses import dataclass
from datetime import datetime
import json

# Setup paths to reuse prototype patterns
sys.path.append(os.path.dirname(__file__))
sys.path.append(os.path.join(os.path.dirname(__file__), '..', '..'))

# Pydantic and Pydantic AI (following prototype pattern)
from pydantic import BaseModel, Field
from pydantic_ai import Agent, RunContext, Tool

# Use OpenAI model with Ollama's OpenAI-compatible endpoint (as in user's example)
from pydantic_ai.models.openai import OpenAIModel
from pydantic_ai.providers.openai import OpenAIProvider

# OpenTelemetry (as used in prototype)
from opentelemetry import trace
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.resources import Resource
from opentelemetry.sdk.trace.export import ConsoleSpanExporter, BatchSpanProcessor

# ========================================================================
# PYDANTIC MODELS (following roberts_rules_models.py pattern)
# These would be GENERATED by Weaver Forge from semantic conventions
# ========================================================================

# Meeting types for Scrum at Scale - using Literal types as in prototype
from enum import Enum

class SASMeetingType(str, Enum):
    EAT = "executive_action_team"
    EMS = "executive_metascrum"
    SOS = "scrum_of_scrums"
    SOSOS = "scrum_of_scrum_of_scrums"
    SPRINT_REVIEW = "sprint_review"
    RETROSPECTIVE = "retrospective"

# Decision types
class DecisionType(str, Enum):
    STRATEGIC = "strategic"
    FINANCIAL = "financial"
    TECHNICAL = "technical"
    PROCESS = "process"
    IMPEDIMENT = "impediment"

# From sas.eat semantic convention
class EATMeeting(BaseModel):
    """Executive Action Team meeting model"""
    id: str = Field(..., description="Unique meeting ID")
    type: Literal["strategic", "operational", "transformation", "impediment"]
    executives_present: int = Field(..., ge=1)
    business_units: List[str]
    strategic_priorities: List[str]
    started_at: datetime = Field(default_factory=datetime.utcnow)
    
class EATDecision(BaseModel):
    """Executive decision from EAT"""
    decision_id: str
    decision_type: DecisionType
    decision: str
    reasoning: str
    confidence: float = Field(..., ge=0.0, le=1.0)
    investment_required: Optional[float] = None
    timeline: str
    business_units_impacted: List[str]
    next_steps: List[str]

# From sas.ems semantic convention
class BacklogItem(BaseModel):
    """Product backlog item"""
    id: str
    title: str
    business_value: int = Field(..., ge=0, le=100)
    time_criticality: int = Field(..., ge=0, le=100)
    risk_reduction: int = Field(..., ge=0, le=100)
    effort: int = Field(..., ge=1)
    wsjf_score: Optional[float] = None
    dependencies: List[str] = Field(default_factory=list)
    assigned_to: Optional[str] = None

class EMSPrioritization(BaseModel):
    """EMS backlog prioritization result"""
    ems_id: str
    prioritized_items: List[BacklogItem]
    release_train_assignments: Dict[str, List[str]]
    portfolio_impact: float
    confidence: float = Field(..., ge=0.0, le=1.0)

# From sas.impediment semantic convention
class Impediment(BaseModel):
    """Enterprise impediment"""
    id: str
    description: str
    severity: Literal["low", "medium", "high", "critical"]
    teams_affected: List[str]
    raised_by: str
    raised_at: datetime = Field(default_factory=datetime.utcnow)
    cost_of_delay: float = Field(..., ge=0)
    resolution: Optional[str] = None
    resolved_at: Optional[datetime] = None

class ImpedimentResolution(BaseModel):
    """Impediment resolution plan"""
    impediment_id: str
    root_causes: List[str]
    resolution_plan: str
    resources_needed: List[str]
    estimated_time: str
    escalation_required: bool
    prevention_measures: List[str]

# Enterprise state (following ParliamentaryState pattern)
class EnterpriseScaledAgileState(BaseModel):
    """Global state for enterprise Scrum at Scale"""
    current_eat_meeting: Optional[EATMeeting] = None
    eat_decisions: Dict[str, EATDecision] = Field(default_factory=dict)
    backlog_items: Dict[str, BacklogItem] = Field(default_factory=dict)
    impediments: Dict[str, Impediment] = Field(default_factory=dict)
    release_trains: List[str] = Field(default=["platform", "mobile", "data", "infrastructure", "ai_ml"])
    teams_count: int = Field(default=125)
    
    def get_active_impediments(self) -> List[Impediment]:
        """Get unresolved impediments sorted by severity"""
        active = [imp for imp in self.impediments.values() if imp.resolution is None]
        severity_order = {"critical": 0, "high": 1, "medium": 2, "low": 3}
        return sorted(active, key=lambda x: severity_order[x.severity])
    
    def calculate_wsjf(self, item: BacklogItem) -> float:
        """Calculate WSJF score"""
        cod = item.business_value + item.time_criticality + item.risk_reduction
        return cod / item.effort if item.effort > 0 else 0

# ========================================================================
# INTEGRATION LAYER (following roberts_integrated_operations.py pattern)
# ========================================================================

# Global enterprise state
enterprise_state = EnterpriseScaledAgileState()

# Setup OTel (as in prototype)
resource = Resource.create({
    "service.name": "unified-sas-implementation",
    "service.version": "1.0.0",
    "sas.teams_count": enterprise_state.teams_count
})

provider = TracerProvider(resource=resource)
provider.add_span_processor(BatchSpanProcessor(ConsoleSpanExporter()))
trace.set_tracer_provider(provider)
tracer = trace.get_tracer(__name__)

# Generated-style result type (following ForgeResult pattern)
class SASResult(BaseModel):
    success: bool
    data: Optional[Dict[str, Any]] = None
    errors: List[str] = Field(default_factory=list)

# Operations that would be generated by Weaver
def sas_eat_meeting_start(
    eat_id: str,
    eat_type: str,
    executives_present: int,
    business_units: List[str],
    strategic_priorities: List[str]
) -> SASResult:
    """Start an EAT meeting (generated from semantic convention)"""
    with tracer.start_as_current_span("sas.eat.start") as span:
        span.set_attribute("sas.eat.id", eat_id)
        span.set_attribute("sas.eat.type", eat_type)
        span.set_attribute("sas.eat.executives_present", executives_present)
        
        try:
            meeting = EATMeeting(
                id=eat_id,
                type=eat_type,
                executives_present=executives_present,
                business_units=business_units,
                strategic_priorities=strategic_priorities
            )
            
            enterprise_state.current_eat_meeting = meeting
            
            return SASResult(
                success=True,
                data={
                    "meeting_id": meeting.id,
                    "type": meeting.type,
                    "status": "in_session"
                }
            )
        except Exception as e:
            span.record_exception(e)
            return SASResult(success=False, errors=[str(e)])

def sas_eat_decision_make(
    decision_id: str,
    decision_type: str,
    decision: str,
    reasoning: str,
    confidence: float,
    **kwargs
) -> SASResult:
    """Record an EAT decision (generated from semantic convention)"""
    with tracer.start_as_current_span("sas.eat.decision") as span:
        span.set_attribute("agent.decision.type", decision_type)
        span.set_attribute("agent.decision.confidence", confidence)
        
        try:
            eat_decision = EATDecision(
                decision_id=decision_id,
                decision_type=decision_type,
                decision=decision,
                reasoning=reasoning,
                confidence=confidence,
                **kwargs
            )
            
            enterprise_state.eat_decisions[decision_id] = eat_decision
            
            return SASResult(
                success=True,
                data=eat_decision.model_dump()
            )
        except Exception as e:
            span.record_exception(e)
            return SASResult(success=False, errors=[str(e)])

# ========================================================================
# PYDANTIC AI AGENTS (following roberts_pydantic_agents.py pattern)
# ========================================================================

# Configure Ollama model using OpenAI-compatible interface (as shown in user's example)
ollama_model = OpenAIModel(
    model_name='qwen3:latest',
    provider=OpenAIProvider(base_url='http://192.168.1.74:11434/v1')
)

# Dependencies pattern from prototype
@dataclass
class SASAgentDeps:
    """Dependencies for SAS agents"""
    agent_name: str
    role: Literal["ceo", "cpo", "scrum_master", "team_member"]
    
    @property
    def state(self) -> EnterpriseScaledAgileState:
        """Get the current enterprise state"""
        return enterprise_state

# Tools following prototype pattern

@Tool
async def start_eat_meeting_tool(
    ctx: RunContext[SASAgentDeps],
    meeting_type: str,
    business_units: List[str]
) -> Dict[str, Any]:
    """Start an Executive Action Team meeting (CEO only)"""
    if ctx.deps.role != "ceo":
        raise ValueError("Only CEO can start EAT meetings")
    
    result = sas_eat_meeting_start(
        eat_id=f"eat-{datetime.utcnow().strftime('%Y%m%d-%H%M')}",
        eat_type=meeting_type,
        executives_present=len(business_units),
        business_units=business_units,
        strategic_priorities=["digital_transformation", "operational_excellence", "market_expansion"]
    )
    
    if result.success:
        return result.data
    else:
        raise ValueError(f"Failed to start EAT: {result.errors}")

@Tool
async def make_strategic_decision_tool(
    ctx: RunContext[SASAgentDeps],
    decision_type: str,
    proposal: str,
    investment: Optional[float] = None
) -> Dict[str, Any]:
    """Make a strategic decision (executives only)"""
    if ctx.deps.role not in ["ceo", "cfo", "cto"]:
        raise ValueError("Only executives can make strategic decisions")
    
    # This is where the AI comes in - analyze the proposal
    decision_text = f"Approve {proposal}" if investment and investment < 100 else f"Defer {proposal} for further analysis"
    reasoning = f"Based on strategic alignment and ROI analysis of {proposal}"
    
    result = sas_eat_decision_make(
        decision_id=f"dec-{datetime.utcnow().timestamp()}",
        decision_type=decision_type,
        decision=decision_text,
        reasoning=reasoning,
        confidence=0.85 if investment and investment < 100 else 0.65,
        investment_required=investment,
        timeline="Q1 2025",
        business_units_impacted=ctx.deps.state.current_eat_meeting.business_units if ctx.deps.state.current_eat_meeting else [],
        next_steps=["Form implementation team", "Develop detailed roadmap", "Allocate resources"]
    )
    
    if result.success:
        return result.data
    else:
        raise ValueError(f"Failed to record decision: {result.errors}")

@Tool
async def prioritize_backlog_tool(
    ctx: RunContext[SASAgentDeps],
    items: List[Dict[str, Any]]
) -> Dict[str, Any]:
    """Prioritize backlog using WSJF (CPO only)"""
    if ctx.deps.role != "cpo":
        raise ValueError("Only CPO can prioritize portfolio backlog")
    
    # Convert to BacklogItem models and calculate WSJF
    backlog_items = []
    for item_data in items:
        item = BacklogItem(**item_data)
        item.wsjf_score = ctx.deps.state.calculate_wsjf(item)
        backlog_items.append(item)
        ctx.deps.state.backlog_items[item.id] = item
    
    # Sort by WSJF score
    prioritized = sorted(backlog_items, key=lambda x: x.wsjf_score or 0, reverse=True)
    
    # Assign to release trains
    assignments = {}
    for item in prioritized:
        # Simple assignment logic - would be more complex in reality
        if "mobile" in item.title.lower():
            train = "mobile"
        elif "data" in item.title.lower() or "analytics" in item.title.lower():
            train = "data"
        elif "ai" in item.title.lower() or "ml" in item.title.lower():
            train = "ai_ml"
        else:
            train = "platform"
        
        if train not in assignments:
            assignments[train] = []
        assignments[train].append(item.id)
    
    result = EMSPrioritization(
        ems_id=f"ems-{datetime.utcnow().strftime('%Y%m%d')}",
        prioritized_items=prioritized,
        release_train_assignments=assignments,
        portfolio_impact=sum(item.business_value for item in prioritized) * 0.01,  # Simplified
        confidence=0.9
    )
    
    return result.model_dump()

@Tool
async def resolve_impediment_tool(
    ctx: RunContext[SASAgentDeps],
    impediment_id: str,
    root_causes: List[str],
    resolution_plan: str
) -> Dict[str, Any]:
    """Resolve an impediment (Scrum Master)"""
    if ctx.deps.role != "scrum_master":
        raise ValueError("Only Scrum Masters can resolve impediments")
    
    impediment = ctx.deps.state.impediments.get(impediment_id)
    if not impediment:
        raise ValueError("Impediment not found")
    
    resolution = ImpedimentResolution(
        impediment_id=impediment_id,
        root_causes=root_causes,
        resolution_plan=resolution_plan,
        resources_needed=["DevOps team", "Platform architect"],
        estimated_time="2 days",
        escalation_required=impediment.severity == "critical",
        prevention_measures=["Add monitoring", "Update runbooks", "Team training"]
    )
    
    # Update impediment
    impediment.resolution = resolution_plan
    impediment.resolved_at = datetime.utcnow()
    
    return resolution.model_dump()

@Tool
async def get_enterprise_state_tool(ctx: RunContext[SASAgentDeps]) -> Dict[str, Any]:
    """Get current enterprise state"""
    state = ctx.deps.state
    
    return {
        "eat_active": state.current_eat_meeting is not None,
        "total_decisions": len(state.eat_decisions),
        "backlog_items": len(state.backlog_items),
        "active_impediments": len(state.get_active_impediments()),
        "critical_impediments": len([i for i in state.get_active_impediments() if i.severity == "critical"]),
        "release_trains": state.release_trains,
        "teams_count": state.teams_count
    }

# ========================================================================
# AGENT DEFINITIONS (following prototype pattern)
# ========================================================================

# CEO Agent
ceo_agent = Agent(
    model=ollama_model,
    deps_type=SASAgentDeps,
    tools=[
        start_eat_meeting_tool,
        make_strategic_decision_tool,
        get_enterprise_state_tool
    ],
    system_prompt="""You are the CEO of a large enterprise implementing Scrum at Scale.
    
Your responsibilities:
- Strategic vision and transformation
- Major investment decisions
- Enterprise impediment resolution
- Stakeholder alignment

You lead Executive Action Team (EAT) meetings and make strategic decisions."""
)

# CPO Agent
cpo_agent = Agent(
    model=ollama_model,
    deps_type=SASAgentDeps,
    tools=[
        prioritize_backlog_tool,
        get_enterprise_state_tool
    ],
    system_prompt="""You are the Chief Product Owner managing a $1.2B portfolio.

You lead Executive MetaScrum (EMS) and:
- Prioritize the portfolio backlog using WSJF
- Coordinate across release trains
- Resolve dependencies
- Optimize value delivery"""
)

# Scrum Master Agent
sm_agent = Agent(
    model=ollama_model,
    deps_type=SASAgentDeps,
    tools=[
        resolve_impediment_tool,
        get_enterprise_state_tool
    ],
    system_prompt="""You are a senior Scrum Master coordinating multiple teams.

You facilitate Scrum of Scrums (SoS) and:
- Identify and resolve impediments
- Coordinate cross-team dependencies
- Ensure teams follow Scrum practices
- Escalate critical issues"""
)

# ========================================================================
# DEMONSTRATION (following prototype patterns)
# ========================================================================

async def demonstrate_unified_sas():
    """Demonstrate the unified Scrum at Scale implementation"""
    
    print("🏢 Unified Scrum at Scale Implementation")
    print("📚 Building on prototype patterns:")
    print("   - Weaver-generated operations")
    print("   - Pydantic models for type safety")
    print("   - Integration layer pattern")
    print("   - Pydantic AI agents with Ollama")
    print("   - Full OTel observability")
    print("="*60)
    
    # Create some impediments to work with
    impediment1 = Impediment(
        id="imp-001",
        description="CI/CD pipeline failing across multiple teams",
        severity="critical",
        teams_affected=["Platform", "Mobile", "Data"],
        raised_by="Platform Team",
        cost_of_delay=50000.0
    )
    enterprise_state.impediments[impediment1.id] = impediment1
    
    # Scenario 1: CEO starts EAT meeting
    print("\n📋 Scenario 1: CEO starts Executive Action Team meeting")
    ceo_deps = SASAgentDeps(agent_name="Sarah Chen", role="ceo")
    
    result = await ceo_agent.run(
        "Start a strategic EAT meeting with engineering, product, and operations units",
        deps=ceo_deps
    )
    print(f"CEO: {result.output}")
    
    # Scenario 2: CEO makes strategic decision
    print("\n📋 Scenario 2: CEO makes strategic investment decision")
    
    result = await ceo_agent.run(
        "Make a strategic decision about investing $75M in an AI platform initiative",
        deps=ceo_deps
    )
    print(f"CEO: {result.output}")
    
    # Scenario 3: CPO prioritizes backlog
    print("\n📋 Scenario 3: CPO prioritizes portfolio backlog")
    cpo_deps = SASAgentDeps(agent_name="David Kumar", role="cpo")
    
    # Create some backlog items
    items = [
        {
            "id": "epic-001",
            "title": "Mobile AI Assistant",
            "business_value": 85,
            "time_criticality": 90,
            "risk_reduction": 60,
            "effort": 34
        },
        {
            "id": "epic-002",
            "title": "Data Analytics Platform",
            "business_value": 90,
            "time_criticality": 70,
            "risk_reduction": 80,
            "effort": 21
        }
    ]
    
    result = await cpo_agent.run(
        f"Prioritize these backlog items using WSJF: {json.dumps(items)}",
        deps=cpo_deps
    )
    print(f"CPO: {result.output}")
    
    # Scenario 4: Scrum Master resolves impediment
    print("\n📋 Scenario 4: Scrum Master resolves critical impediment")
    sm_deps = SASAgentDeps(agent_name="Lisa Wang", role="scrum_master")
    
    result = await sm_agent.run(
        f"Resolve the critical impediment {impediment1.id} about CI/CD pipeline failures",
        deps=sm_deps
    )
    print(f"SM: {result.output}")
    
    # Show final state
    print("\n📊 Final Enterprise State:")
    state_result = await ceo_agent.run(
        "Show me the current enterprise state",
        deps=ceo_deps
    )
    print(f"State: {state_result.output}")
    
    print("\n✅ Demonstration complete!")
    print("🔍 All operations tracked via OTel spans")
    print("📊 State managed through Pydantic models")
    print("🤖 Decisions made by Ollama-powered agents")

if __name__ == "__main__":
    print("🚀 Running Unified Scrum at Scale Implementation")
    print("⚡ Using established prototype patterns")
    print("="*60)
    
    asyncio.run(demonstrate_unified_sas())