{
    "sourceFile": "src/weavergen/cli.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1751480342272,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751480771051,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -16,8 +16,9 @@\n from .cli_workflow import workflow_app\n from .cli_debug import debug_app\n from .commands.forge import forge_app\n from .commands.generate import generate_app\n+from .commands.weaver import weaver_app\n from .commands.agents import agents_app\n from .commands.bpmn import bpmn_app\n from .commands.debug import debug_app as commands_debug_app\n from .commands.templates import templates_app\n@@ -30,9 +31,10 @@\n \n # Add subcommands\n app.add_typer(workflow_app, name=\"workflow\", help=\"Manage BPMN workflows\")\n app.add_typer(debug_app, name=\"debug\", help=\"Debug and visualize OpenTelemetry spans\")\n-app.add_typer(forge_app, name=\"forge\", help=\"Weaver Forge lifecycle commands\")\n+app.add_typer(weaver_app, name=\"weaver\", help=\"Direct Weaver binary commands\")\n+app.add_typer(forge_app, name=\"forge\", help=\"Weaver Forge code generation commands\")\n app.add_typer(generate_app, name=\"generate\", help=\"Code generation commands\")\n app.add_typer(agents_app, name=\"agents\", help=\"AI agent operations\")\n app.add_typer(bpmn_app, name=\"bpmn\", help=\"BPMN workflow execution\")\n app.add_typer(templates_app, name=\"templates\", help=\"Template management\")\n"
                },
                {
                    "date": 1751480848056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -17,9 +17,8 @@\n from .cli_debug import debug_app\n from .commands.forge import forge_app\n from .commands.generate import generate_app\n from .commands.weaver import weaver_app\n-from .commands.agents import agents_app\n from .commands.bpmn import bpmn_app\n from .commands.debug import debug_app as commands_debug_app\n from .commands.templates import templates_app\n from .commands.semantic import semantic_app\n"
                }
            ],
            "date": 1751480342272,
            "name": "Commit-0",
            "content": "\"\"\"WeaverGen v2 CLI with BPMN workflow support.\"\"\"\n\nimport json\nimport logging\nfrom pathlib import Path\nfrom typing import List, Optional\n\nimport typer\nfrom rich import print as rprint\nfrom rich.console import Console\nfrom rich.table import Table\n\n\nfrom .engine.simple_engine import SimpleBpmnEngine\nfrom .engine.service_task import WeaverGenServiceEnvironment\nfrom .cli_workflow import workflow_app\nfrom .cli_debug import debug_app\nfrom .commands.forge import forge_app\nfrom .commands.generate import generate_app\nfrom .commands.agents import agents_app\nfrom .commands.bpmn import bpmn_app\nfrom .commands.debug import debug_app as commands_debug_app\nfrom .commands.templates import templates_app\nfrom .commands.semantic import semantic_app\nfrom .commands.mining import mining_app\nfrom .commands.xes import xes_app\n\napp = typer.Typer(help=\"WeaverGen v2 - BPMN-driven semantic code generation\")\nconsole = Console()\n\n# Add subcommands\napp.add_typer(workflow_app, name=\"workflow\", help=\"Manage BPMN workflows\")\napp.add_typer(debug_app, name=\"debug\", help=\"Debug and visualize OpenTelemetry spans\")\napp.add_typer(forge_app, name=\"forge\", help=\"Weaver Forge lifecycle commands\")\napp.add_typer(generate_app, name=\"generate\", help=\"Code generation commands\")\napp.add_typer(agents_app, name=\"agents\", help=\"AI agent operations\")\napp.add_typer(bpmn_app, name=\"bpmn\", help=\"BPMN workflow execution\")\napp.add_typer(templates_app, name=\"templates\", help=\"Template management\")\napp.add_typer(semantic_app, name=\"semantic\", help=\"AI-powered semantic generation\")\napp.add_typer(mining_app, name=\"mining\", help=\"Process mining and XES conversion\")\napp.add_typer(xes_app, name=\"xes\", help=\"Process mining and XES operations\")\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Initialize components (singleton pattern for demo)\n_engine = None\n\ndef get_engine():\n    global _engine\n    if _engine is None:\n        script_env = WeaverGenServiceEnvironment()\n        _engine = SimpleBpmnEngine(script_env)\n    return _engine\n\nengine = get_engine()\n\n\n@app.command()\ndef add(\n    process_id: Optional[str] = typer.Option(None, \"--process\", \"-p\", help=\"The top-level BPMN Process ID\"),\n    collaboration_id: Optional[str] = typer.Option(None, \"--collaboration\", \"-c\", help=\"The ID of the collaboration\"),\n    bpmn_files: List[str] = typer.Option([], \"--bpmn\", \"-b\", help=\"BPMN files to load\"),\n    dmn_files: List[str] = typer.Option([], \"--dmn\", \"-d\", help=\"DMN files to load\"),\n):\n    \"\"\"Add a workflow specification.\"\"\"\n    if not process_id and not collaboration_id:\n        console.print(\"[red]Error: Either --process or --collaboration must be specified[/red]\")\n        raise typer.Exit(1)\n    \n    if process_id and collaboration_id:\n        console.print(\"[red]Error: Only one of --process or --collaboration can be specified[/red]\")\n        raise typer.Exit(1)\n    \n    try:\n        if process_id:\n            spec_id = engine.add_spec(process_id, bpmn_files)\n            console.print(f\"[green]Added process '{process_id}' with ID: {spec_id}[/green]\")\n        else:\n            # For now, treat collaboration as process\n            spec_id = engine.add_spec(collaboration_id, bpmn_files)\n            console.print(f\"[green]Added collaboration '{collaboration_id}' with ID: {spec_id}[/green]\")\n    except Exception as e:\n        console.print(f\"[red]Error adding workflow: {e}[/red]\")\n        raise typer.Exit(1)\n\n\n@app.command()\ndef list_specs():\n    \"\"\"List available workflow specifications.\"\"\"\n    specs = engine.list_specs()\n    \n    if not specs:\n        console.print(\"[yellow]No workflow specifications found[/yellow]\")\n        return\n    \n    table = Table(title=\"Workflow Specifications\")\n    table.add_column(\"ID\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Name\", style=\"magenta\")\n    table.add_column(\"File\", style=\"green\")\n    \n    for spec_id, name, filename in specs:\n        table.add_row(spec_id, name, filename)\n    \n    console.print(table)\n\n\n@app.command()\ndef list_instances(include_completed: bool = typer.Option(False, \"--all\", \"-a\", help=\"Include completed workflows\")):\n    \"\"\"List workflow instances.\"\"\"\n    workflows = engine.list_workflows(include_completed)\n    \n    if not workflows:\n        console.print(\"[yellow]No workflow instances found[/yellow]\")\n        return\n    \n    table = Table(title=\"Workflow Instances\")\n    table.add_column(\"ID\", style=\"cyan\", no_wrap=True)\n    table.add_column(\"Name\", style=\"magenta\")\n    table.add_column(\"Active\", style=\"green\")\n    table.add_column(\"Started\", style=\"blue\")\n    table.add_column(\"Updated\", style=\"blue\")\n    \n    for wf_id, name, filename, active, started, updated in workflows:\n        table.add_row(\n            wf_id,\n            name,\n            \"✓\" if active else \"✗\",\n            started,\n            updated or \"\"\n        )\n    \n    console.print(table)\n\n\n@app.command()\ndef run(\n    spec_id: str = typer.Argument(help=\"The ID of the specification to run\"),\n    data: Optional[str] = typer.Option(None, \"--data\", \"-d\", help=\"Initial workflow data as JSON\"),\n):\n    \"\"\"Run a workflow to completion.\"\"\"\n    try:\n        # Start the workflow\n        instance = engine.start_workflow(spec_id)\n        \n        # Set initial data if provided\n        if data:\n            initial_data = json.loads(data)\n            instance.workflow.data.update(initial_data)\n        \n        # Run until completion or user input required\n        instance.run_until_user_input_required()\n        instance.save()\n        \n        # Display results\n        if instance.workflow.is_completed():\n            console.print(\"[green]Workflow completed successfully![/green]\")\n        else:\n            console.print(\"[yellow]Workflow paused - user input required[/yellow]\")\n        \n        # Show workflow data\n        console.print(\"\\n[bold]Workflow Data:[/bold]\")\n        console.print(json.dumps(instance.data, indent=2))\n        \n    except Exception as e:\n        console.print(f\"[red]Error running workflow: {e}[/red]\")\n        raise typer.Exit(1)\n\n\n@app.command()\ndef delete_spec(\n    spec_id: str = typer.Argument(help=\"The ID of the specification to delete\"),\n):\n    \"\"\"Delete a workflow specification.\"\"\"\n    try:\n        engine.delete_workflow_spec(spec_id)\n        console.print(f\"[green]Deleted workflow specification: {spec_id}[/green]\")\n    except Exception as e:\n        console.print(f\"[red]Error deleting specification: {e}[/red]\")\n        raise typer.Exit(1)\n\n\n@app.command()\ndef delete_instance(\n    wf_id: str = typer.Argument(help=\"The ID of the workflow instance to delete\"),\n):\n    \"\"\"Delete a workflow instance.\"\"\"\n    try:\n        engine.delete_workflow(wf_id)\n        console.print(f\"[green]Deleted workflow instance: {wf_id}[/green]\")\n    except Exception as e:\n        console.print(f\"[red]Error deleting workflow: {e}[/red]\")\n        raise typer.Exit(1)\n\n\n@app.command()\ndef generate(\n    semantic_file: str = typer.Argument(help=\"Path to semantic convention YAML file\"),\n    language: str = typer.Option(\"python\", \"--language\", \"-l\", help=\"Target language for code generation\"),\n    output: Optional[str] = typer.Option(None, \"--output\", \"-o\", help=\"Output directory\"),\n):\n    \"\"\"Generate code from semantic conventions (convenience command).\"\"\"\n    console.print(\"[cyan]Generating code from semantic conventions...[/cyan]\")\n    console.print(f\"  Input: {semantic_file}\")\n    console.print(f\"  Language: {language}\")\n    console.print(f\"  Output: {output or 'stdout'}\")\n    \n    # This would integrate with the actual Weaver Forge\n    console.print(\"\\n[yellow]Note: This is a placeholder. Actual Weaver Forge integration pending.[/yellow]\")\n\n\n@app.command()\ndef validate(\n    semantic_file: str = typer.Argument(help=\"Path to semantic convention YAML file\"),\n):\n    \"\"\"Validate semantic convention file (convenience command).\"\"\"\n    console.print(f\"[cyan]Validating semantic convention file: {semantic_file}[/cyan]\")\n    \n    # This would validate against OTel semantic conventions\n    console.print(\"\\n[yellow]Note: This is a placeholder. Actual validation logic pending.[/yellow]\")\n\n\n@app.command()\ndef fire(name: str = \"Chell\") -> None:\n    \"\"\"Fire portal gun (legacy command).\"\"\"\n    rprint(f\"[bold red]Alert![/bold red] {name} fired [green]portal gun[/green] :boom:\")\n\n\n@app.callback()\ndef main_callback(\n    version: bool = typer.Option(False, \"--version\", \"-v\", help=\"Show version\"),\n):\n    \"\"\"WeaverGen v2 - BPMN-driven semantic code generation.\"\"\"\n    if version:\n        console.print(\"[cyan]WeaverGen v2.0.0[/cyan]\")\n        raise typer.Exit(0)\n"
        }
    ]
}