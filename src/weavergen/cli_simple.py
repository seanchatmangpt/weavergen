#!/usr/bin/env python3
"""
Simple CLI for WeaverGen - 80/20 approach

Just the essential commands that solve the core JTBD.
"""

import asyncio
from pathlib import Path
from typing import List, Optional

import typer
from rich.console import Console

from .core_simple import generate_code, WeaverGen

app = typer.Typer(name="weavergen", help="Simple semantic convention code generator")
console = Console()


@app.command()
def generate(
    semantic_file: str = typer.Argument(..., help="Path to semantic convention YAML file"),
    languages: List[str] = typer.Option(["python"], "--lang", "-l", help="Target languages"),
    output_dir: str = typer.Option("./generated", "--output", "-o", help="Output directory"),
):
    """Generate code from semantic conventions - simple and fast."""
    
    # Validate semantic file exists
    if not Path(semantic_file).exists():
        console.print(f"❌ Error: Semantic file not found: {semantic_file}")
        raise typer.Exit(1)
    
    # Run generation
    asyncio.run(generate_code(semantic_file, languages, output_dir))


@app.command()
def check():
    """Check if WeaverGen is properly set up."""
    
    console.print("[bold blue]🔍 WeaverGen Setup Check[/bold blue]\n")
    
    generator = WeaverGen()
    ready, issues = generator.check_requirements()
    
    if ready:
        console.print("✅ All requirements met! Ready to generate code.\n")
        
        # Show weaver info
        if generator.weaver_path:
            console.print(f"📍 Weaver location: {generator.weaver_path}")
            
            # Try to get version
            import subprocess
            try:
                result = subprocess.run(
                    [str(generator.weaver_path), "--version"],
                    capture_output=True,
                    text=True,
                    timeout=5
                )
                if result.returncode == 0:
                    console.print(f"📦 Weaver version: {result.stdout.strip()}")
            except:
                pass
        
        console.print(f"📁 Templates directory: {generator.templates_dir}")
        
        # Show available templates
        if generator.templates_dir.exists():
            templates = list(generator.templates_dir.glob("*.j2"))
            if templates:
                console.print(f"\n📄 Available templates:")
                for template in templates:
                    console.print(f"  • {template.name}")
            else:
                console.print("\n⚠️ No templates found - basic templates will be created automatically")
                
    else:
        console.print("❌ Setup issues found:\n")
        for issue in issues:
            console.print(f"  {issue}")
        
        console.print("\n💡 To fix:")
        console.print("  1. Install Weaver: cargo install weaver-forge")
        console.print("  2. Run 'weavergen check' again")


@app.command()
def init(
    path: str = typer.Option(".", "--path", "-p", help="Directory to initialize"),
):
    """Initialize a WeaverGen project with sample files."""
    
    project_path = Path(path)
    project_path.mkdir(parents=True, exist_ok=True)
    
    console.print(f"[bold blue]🚀 Initializing WeaverGen project in {project_path}[/bold blue]\n")
    
    # Create sample semantic convention
    semantic_dir = project_path / "semantic-conventions"
    semantic_dir.mkdir(exist_ok=True)
    
    sample_semantic = """# Sample HTTP Semantic Convention
id: http.server
brief: HTTP server semantic conventions for observability
attributes:
  - name: http.request.method
    type: string
    brief: HTTP request method
    examples: 
      - GET
      - POST
      - PUT
      - DELETE
    requirement_level: required
    
  - name: http.response.status_code
    type: int
    brief: HTTP response status code
    examples: 
      - 200
      - 404
      - 500
    requirement_level: required
    
  - name: http.request.path
    type: string
    brief: The request path
    examples:
      - /api/users
      - /health
    requirement_level: recommended
    
  - name: http.request.duration
    type: double
    brief: Request duration in milliseconds
    requirement_level: recommended
"""
    
    semantic_file = semantic_dir / "http.yaml"
    semantic_file.write_text(sample_semantic)
    console.print(f"✅ Created sample semantic convention: {semantic_file}")
    
    # Create templates directory
    templates_dir = project_path / "templates"
    templates_dir.mkdir(exist_ok=True)
    
    # Create sample Python template
    python_template = """# Generated from {{ semantic.id }}
\"\"\"
{{ semantic.brief }}

Generated by WeaverGen from OpenTelemetry semantic conventions.
\"\"\"

from dataclasses import dataclass
from typing import Optional, Union
from enum import Enum


class HttpMethod(str, Enum):
    \"\"\"HTTP request methods.\"\"\"
    GET = "GET"
    POST = "POST"
    PUT = "PUT"
    DELETE = "DELETE"
    PATCH = "PATCH"
    HEAD = "HEAD"
    OPTIONS = "OPTIONS"


@dataclass
class HttpServerAttributes:
    \"\"\"{{ semantic.brief }}\"\"\"
    
    # Required attributes
    http_request_method: HttpMethod
    http_response_status_code: int
    
    # Recommended attributes
    http_request_path: Optional[str] = None
    http_request_duration: Optional[float] = None
    
    def to_dict(self) -> dict:
        \"\"\"Convert to OpenTelemetry attribute dictionary.\"\"\"
        attrs = {
            "http.request.method": self.http_request_method.value,
            "http.response.status_code": self.http_response_status_code,
        }
        
        if self.http_request_path is not None:
            attrs["http.request.path"] = self.http_request_path
            
        if self.http_request_duration is not None:
            attrs["http.request.duration"] = self.http_request_duration
            
        return attrs
"""
    
    python_template_file = templates_dir / "python_http.j2"
    python_template_file.write_text(python_template)
    console.print(f"✅ Created Python template: {python_template_file}")
    
    # Create .gitignore
    gitignore = """# Generated files
generated/
*.pyc
__pycache__/
.DS_Store

# IDE
.vscode/
.idea/
"""
    
    gitignore_file = project_path / ".gitignore"
    gitignore_file.write_text(gitignore)
    console.print(f"✅ Created .gitignore: {gitignore_file}")
    
    # Create README
    readme = f"""# WeaverGen Project

This project uses WeaverGen to generate code from OpenTelemetry semantic conventions.

## Quick Start

1. Generate code from semantic conventions:
   ```bash
   weavergen generate semantic-conventions/http.yaml --lang python --output generated
   ```

2. Check available languages:
   ```bash
   weavergen generate semantic-conventions/http.yaml --lang python,go,java --output generated
   ```

## Project Structure

```
{project_path.name}/
├── semantic-conventions/   # Your semantic convention YAML files
│   └── http.yaml          # Sample HTTP semantic convention
├── templates/             # Custom Jinja2 templates (optional)
│   └── python_http.j2     # Sample Python template
└── generated/             # Generated code output (git ignored)
```

## Adding New Semantic Conventions

1. Create a new YAML file in `semantic-conventions/`
2. Run `weavergen generate` to generate code
3. Find your generated code in `generated/<language>/`

## Custom Templates

WeaverGen will use custom templates from the `templates/` directory if available.
Template naming convention: `<language>_<convention>.j2`

For more information: https://github.com/seanchatmangpt/weavergen
"""
    
    readme_file = project_path / "README.md"
    readme_file.write_text(readme)
    console.print(f"✅ Created README: {readme_file}")
    
    console.print(f"\n✨ Project initialized successfully!")
    console.print(f"\n📋 Next steps:")
    console.print(f"  1. cd {project_path}")
    console.print(f"  2. weavergen check  # Verify setup")
    console.print(f"  3. weavergen generate semantic-conventions/http.yaml --lang python")


@app.command()
def version():
    """Show WeaverGen version."""
    console.print("WeaverGen v1.0.0 (80/20 Edition)")
    console.print("Simple semantic convention code generator")


if __name__ == "__main__":
    app()