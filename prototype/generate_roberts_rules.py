#!/usr/bin/env python3
"""
Generate Robert's Rules of Order implementation using Weaver Forge.
This demonstrates applying the semantic quine architecture to parliamentary procedures.
"""

import subprocess
import os
import shutil
from pathlib import Path
import sys

def create_registry_structure(yaml_path: str) -> str:
    """Create proper registry structure for a single YAML file"""
    registry_dir = "temp_registry"
    model_dir = f"{registry_dir}/model"
    
    # Clean up any existing directory
    if os.path.exists(registry_dir):
        shutil.rmtree(registry_dir)
    
    # Create the structure
    os.makedirs(model_dir, exist_ok=True)
    
    # Copy the YAML file to the model directory
    shutil.copy(yaml_path, model_dir)
    
    return registry_dir

def generate_roberts_rules():
    """Generate the 4-layer architecture for Robert's Rules"""
    
    print("🏛️  Generating Robert's Rules of Order implementation...")
    
    # Check if Weaver CLI is available
    try:
        subprocess.run(["weaver", "--help"], capture_output=True, check=True)
    except (subprocess.CalledProcessError, FileNotFoundError):
        print("❌ Weaver CLI not found. Please install: cargo install weaver_forge")
        return False
    
    # Create registry structure
    registry_path = create_registry_structure("roberts-rules-simple.yaml")
    
    try:
        # Generate the 4-layer architecture
        cmd = [
            "weaver", "registry", "generate",
            "-r", registry_path,
            "-t", "templates",
            "python",
            "output/roberts"
        ]
        
        print(f"Running: {' '.join(cmd)}")
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"❌ Generation failed: {result.stderr}")
            return False
        
        print("✅ Generated 4-layer architecture for Robert's Rules")
        
        # Create __init__.py files
        for subdir in ["commands", "operations", "runtime", "contracts"]:
            init_path = Path(f"output/roberts/{subdir}/__init__.py")
            init_path.parent.mkdir(parents=True, exist_ok=True)
            init_path.touch()
        
        # Create a main __init__.py
        Path("output/roberts/__init__.py").write_text("""
# Robert's Rules of Order - Generated Implementation
from .commands.roberts import *
""")
        
        print("✅ Created package structure")
        
        # Now we need to implement the runtime layer for Robert's Rules
        implement_roberts_runtime()
        
        # And update the operations layer with actual logic
        implement_roberts_operations()
        
        return True
        
    finally:
        # Clean up temporary registry
        if os.path.exists(registry_path):
            shutil.rmtree(registry_path)

def implement_roberts_runtime():
    """Implement the runtime layer for Robert's Rules"""
    runtime_code = '''# Generated by Weaver Forge - Runtime Layer for Robert's Rules
# This layer handles all side effects for parliamentary procedures

from typing import Dict, List, Optional, Tuple, Any
from pathlib import Path
import json
import datetime
from dataclasses import dataclass, asdict
from enum import Enum

# Meeting state management
class MeetingState:
    """Manages the state of a Robert's Rules meeting"""
    
    def __init__(self):
        self.meetings: Dict[str, Dict[str, Any]] = {}
        self.motions: Dict[str, Dict[str, Any]] = {}
        self.current_meeting_id: Optional[str] = None
        self.speaking_queue: List[Tuple[str, str]] = []  # (member, purpose)
    
    def start_meeting(self, meeting_id: str, meeting_type: str, quorum: int,
                     members_present: int, chair: str, secretary: str,
                     agenda_items: Optional[Dict[str, str]] = None) -> bool:
        """Start a new meeting"""
        if meeting_id in self.meetings:
            return False
        
        self.meetings[meeting_id] = {
            "id": meeting_id,
            "type": meeting_type,
            "quorum": quorum,
            "members_present": members_present,
            "chair": chair,
            "secretary": secretary,
            "agenda_items": agenda_items or {},
            "start_time": datetime.datetime.now().isoformat(),
            "motions": [],
            "minutes": []
        }
        self.current_meeting_id = meeting_id
        return True
    
    def add_motion(self, motion_id: str, motion_type: str, text: str,
                   mover: str, requires_second: bool, debatable: bool,
                   vote_required: str) -> bool:
        """Add a new motion"""
        if motion_id in self.motions:
            return False
        
        self.motions[motion_id] = {
            "id": motion_id,
            "type": motion_type,
            "text": text,
            "mover": mover,
            "seconder": None,
            "requires_second": requires_second,
            "debatable": debatable,
            "vote_required": vote_required,
            "status": "pending",
            "debate_history": [],
            "vote_result": None
        }
        
        if self.current_meeting_id:
            self.meetings[self.current_meeting_id]["motions"].append(motion_id)
        
        return True
    
    def second_motion(self, motion_id: str, seconder: str) -> bool:
        """Second a motion"""
        if motion_id not in self.motions:
            return False
        
        motion = self.motions[motion_id]
        if not motion["requires_second"]:
            return False
        
        if motion["status"] != "pending":
            return False
        
        motion["seconder"] = seconder
        motion["status"] = "seconded"
        return True
    
    def record_vote(self, motion_id: str, yes_count: int, no_count: int,
                    abstain_count: int, vote_method: str) -> str:
        """Record vote results"""
        if motion_id not in self.motions:
            return "failed"
        
        motion = self.motions[motion_id]
        total_votes = yes_count + no_count
        
        # Determine if motion passed based on required threshold
        if motion["vote_required"] == "majority":
            passed = yes_count > no_count
        elif motion["vote_required"] == "two_thirds":
            passed = yes_count >= (total_votes * 2 / 3)
        elif motion["vote_required"] == "unanimous":
            passed = yes_count == total_votes and no_count == 0
        else:
            passed = False
        
        result = "passed" if passed else "failed"
        if yes_count == no_count:
            result = "tied"
        
        motion["vote_result"] = {
            "method": vote_method,
            "yes": yes_count,
            "no": no_count,
            "abstain": abstain_count,
            "result": result
        }
        motion["status"] = result
        
        return result
    
    def add_to_speaking_queue(self, member: str, purpose: str) -> int:
        """Add member to speaking queue and return position"""
        self.speaking_queue.append((member, purpose))
        return len(self.speaking_queue)
    
    def next_speaker(self) -> Optional[Tuple[str, str]]:
        """Get next speaker from queue"""
        if self.speaking_queue:
            return self.speaking_queue.pop(0)
        return None
    
    def save_minutes(self, meeting_id: str, minutes_path: str) -> bool:
        """Save meeting minutes to file"""
        if meeting_id not in self.meetings:
            return False
        
        meeting = self.meetings[meeting_id]
        minutes = {
            "meeting": meeting,
            "motions": [self.motions[m_id] for m_id in meeting["motions"] if m_id in self.motions]
        }
        
        Path(minutes_path).parent.mkdir(parents=True, exist_ok=True)
        with open(minutes_path, 'w') as f:
            json.dump(minutes, f, indent=2)
        
        return True

# Global meeting state
meeting_state = MeetingState()

# Parliamentary validation functions
def validate_quorum(members_present: int, quorum: int) -> bool:
    """Check if quorum is met"""
    return members_present >= quorum

def validate_motion_type(motion_type: str) -> bool:
    """Validate motion type is recognized"""
    valid_types = ["main", "subsidiary", "privileged", "incidental"]
    return motion_type in valid_types

def validate_vote_method(method: str) -> bool:
    """Validate voting method"""
    valid_methods = ["voice", "show_of_hands", "roll_call", "ballot", "unanimous_consent"]
    return method in valid_methods

def check_motion_precedence(current_motion_type: str, new_motion_type: str) -> bool:
    """Check if new motion has precedence over current motion"""
    precedence = {
        "privileged": 4,
        "incidental": 3,
        "subsidiary": 2,
        "main": 1
    }
    return precedence.get(new_motion_type, 0) >= precedence.get(current_motion_type, 0)

# Mock telemetry for Roberts Rules
def get_mock_telemetry_for_roberts() -> List[Dict[str, Any]]:
    """Get mock telemetry data for Roberts Rules operations"""
    return [
        {"operation": "roberts_meeting_start", "success": True, "duration": 0.002},
        {"operation": "roberts_motion_make", "success": True, "duration": 0.001},
        {"operation": "roberts_motion_second", "success": True, "duration": 0.001},
        {"operation": "roberts_vote_record", "success": True, "duration": 0.003},
        {"operation": "roberts_point_of_order_raise", "success": True, "duration": 0.001},
        {"operation": "roberts_recognition_request", "success": True, "duration": 0.001},
    ]
'''
    
    Path("output/roberts/runtime/roberts.py").write_text(runtime_code)
    print("✅ Implemented Roberts Rules runtime layer")

def implement_roberts_operations():
    """Implement the operations layer for Robert's Rules"""
    operations_code = '''# Generated by Weaver Forge - Operations Layer for Robert's Rules
# AI-EDITABLE: This layer contains business logic for parliamentary procedures

import os
from typing import Optional, List, Dict, Any
from pathlib import Path

# Import contracts and runtime
from contracts.roberts import *
from runtime.roberts import *

# Import the result type
from commands.roberts import ForgeResult

def roberts_meeting_start_execute(
    meeting_id: str,
    meeting_type: str,
    quorum: int,
    members_present: int,
    chair: str,
    secretary: str,
    agenda_items: Optional[Dict[str, str]] = None,
    minutes_path: Optional[str] = None,
) -> ForgeResult:
    """Start a new meeting according to Robert's Rules"""
    try:
        # Validate quorum
        if not validate_quorum(members_present, quorum):
            return ForgeResult(
                success=False,
                errors=[f"Quorum not met. Required: {quorum}, Present: {members_present}"]
            )
        
        # Start the meeting
        success = meeting_state.start_meeting(
            meeting_id=meeting_id,
            meeting_type=meeting_type,
            quorum=quorum,
            members_present=members_present,
            chair=chair,
            secretary=secretary,
            agenda_items=agenda_items
        )
        
        if not success:
            return ForgeResult(
                success=False,
                errors=[f"Meeting {meeting_id} already exists"]
            )
        
        return ForgeResult(
            success=True,
            data={
                "meeting_id": meeting_id,
                "status": "in_session",
                "quorum_met": True
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_motion_make_execute(
    motion_id: str,
    motion_type: str,
    motion_text: str,
    mover: str,
    requires_second: bool,
    debatable: bool,
    vote_required: str,
    motion_status: str,
    seconder: Optional[str] = None,
) -> ForgeResult:
    """Make a motion according to Robert's Rules"""
    try:
        # Validate motion type
        if not validate_motion_type(motion_type):
            return ForgeResult(
                success=False,
                errors=[f"Invalid motion type: {motion_type}"]
            )
        
        # Add the motion
        success = meeting_state.add_motion(
            motion_id=motion_id,
            motion_type=motion_type,
            text=motion_text,
            mover=mover,
            requires_second=requires_second,
            debatable=debatable,
            vote_required=vote_required
        )
        
        if not success:
            return ForgeResult(
                success=False,
                errors=[f"Motion {motion_id} already exists"]
            )
        
        # Handle immediate second if provided
        if seconder and requires_second:
            meeting_state.second_motion(motion_id, seconder)
            motion_status = "seconded"
        else:
            motion_status = "pending"
        
        return ForgeResult(
            success=True,
            data={
                "motion_id": motion_id,
                "status": motion_status,
                "requires_second": requires_second,
                "next_step": "second" if requires_second and not seconder else "debate" if debatable else "vote"
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_motion_second_execute(
    motion_id: str,
    motion_type: str,
    motion_text: str,
    mover: str,
    seconder: str,
    requires_second: bool,
    debatable: bool,
    vote_required: str,
    motion_status: str,
) -> ForgeResult:
    """Second a motion"""
    try:
        success = meeting_state.second_motion(motion_id, seconder)
        
        if not success:
            return ForgeResult(
                success=False,
                errors=["Motion cannot be seconded (may not exist, not require second, or already seconded)"]
            )
        
        return ForgeResult(
            success=True,
            data={
                "motion_id": motion_id,
                "status": "seconded",
                "next_step": "debate" if debatable else "vote"
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_vote_record_execute(
    motion_id: str,
    vote_method: str,
    yes_count: int,
    no_count: int,
    vote_result: str,
    abstain_count: Optional[int] = None,
) -> ForgeResult:
    """Record a vote on a motion"""
    try:
        # Validate vote method
        if not validate_vote_method(vote_method):
            return ForgeResult(
                success=False,
                errors=[f"Invalid vote method: {vote_method}"]
            )
        
        # Record the vote
        result = meeting_state.record_vote(
            motion_id=motion_id,
            yes_count=yes_count,
            no_count=no_count,
            abstain_count=abstain_count or 0,
            vote_method=vote_method
        )
        
        return ForgeResult(
            success=True,
            data={
                "motion_id": motion_id,
                "result": result,
                "yes": yes_count,
                "no": no_count,
                "abstain": abstain_count or 0
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_point_of_order_raise_execute(
    member: str,
    issue: str,
    ruling: Optional[str] = None,
    appealed: Optional[bool] = None,
) -> ForgeResult:
    """Raise a point of order"""
    try:
        # Record the point of order
        point_data = {
            "member": member,
            "issue": issue,
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        # Chair makes ruling if provided
        if ruling:
            point_data["ruling"] = ruling
            
        # Handle appeal if applicable
        if appealed is not None:
            point_data["appealed"] = appealed
            if appealed:
                # An appeal would create a new motion
                appeal_motion_id = f"appeal-{datetime.datetime.now().timestamp()}"
                meeting_state.add_motion(
                    motion_id=appeal_motion_id,
                    motion_type="incidental",
                    text=f"Appeal the ruling of the chair regarding: {issue}",
                    mover=member,
                    requires_second=True,
                    debatable=True,
                    vote_required="majority"
                )
                point_data["appeal_motion_id"] = appeal_motion_id
        
        return ForgeResult(
            success=True,
            data=point_data
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_recognition_request_execute(
    member: str,
    purpose: str,
    granted: bool,
    queue_position: Optional[int] = None,
) -> ForgeResult:
    """Request recognition to speak"""
    try:
        if granted:
            # Member is recognized immediately
            return ForgeResult(
                success=True,
                data={
                    "member": member,
                    "purpose": purpose,
                    "status": "recognized",
                    "may_proceed": True
                }
            )
        else:
            # Add to speaking queue
            position = meeting_state.add_to_speaking_queue(member, purpose)
            return ForgeResult(
                success=True,
                data={
                    "member": member,
                    "purpose": purpose,
                    "status": "queued",
                    "queue_position": position
                }
            )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])
'''
    
    # Read the generated operations file and replace the placeholder implementations
    ops_file = Path("output/roberts/operations/roberts.py")
    if ops_file.exists():
        content = ops_file.read_text()
        # Find where the functions start and preserve the imports/setup
        import_end = content.find("def roberts_meeting_start_execute")
        if import_end > 0:
            # Keep the generated imports and function signatures, replace implementations
            generated_prefix = content[:import_end]
            ops_file.write_text(generated_prefix + operations_code.split("def roberts_meeting_start_execute")[1])
    else:
        ops_file.write_text(operations_code)
    
    print("✅ Implemented Roberts Rules operations layer")

if __name__ == "__main__":
    success = generate_roberts_rules()
    if success:
        print("\n🎉 Successfully generated Robert's Rules of Order implementation!")
        print("\nThe system now supports:")
        print("  - Meeting management with quorum validation")
        print("  - Motion handling (main, subsidiary, privileged, incidental)")
        print("  - Voting with different thresholds (majority, 2/3, unanimous)")
        print("  - Points of order and appeals")
        print("  - Speaker recognition and queue management")
        print("  - Full OpenTelemetry observability")
        print("\nUse: from output.roberts import *")
    else:
        print("\n❌ Failed to generate Robert's Rules implementation")
        sys.exit(1)