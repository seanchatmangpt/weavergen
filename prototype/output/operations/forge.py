# Generated by Weaver Forge - Operations Layer
# AI-EDITABLE: This layer contains business logic that can be modified by AI
# The function signatures and contracts must be maintained

import os
from typing import Optional, List, Dict, Any
from pathlib import Path

# Import contracts and runtime
from contracts.forge import *
from runtime.forge import *

# Import the result type
from commands.forge import ForgeResult

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")


# AI-EDITABLE: forge.semantic.generate
def forge_semantic_generate_execute(
    input_description: str,
    output_path: str,
    llm_model: str,
    validation_status: str,
    llm_temperature: Optional[float] = None,
    validation_errors: Optional[List[str]] = None,
) -> ForgeResult:
    """Generate semantic convention from natural language description
    
    Args:
        input_description: Natural language description to convert to semantic convention
        output_path: Path where semantic YAML will be written
        llm_model: LLM model identifier used for generation
        llm_temperature: Temperature parameter for LLM generation
        validation_status: Weaver validation result
        validation_errors: Validation error messages if any
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # Wrap Weaver CLI for semantic generation
    try:
        # Create a basic semantic convention file
        basic_semconv = create_basic_semantic_convention(
            description=input_description,
            output_path=output_path
        )
        write_file(output_path, basic_semconv)
        
        # Validate with Weaver CLI
        is_valid, errors = weaver_registry_check(output_path)
        
        # Update validation status
        validation_status = "passed" if is_valid else "failed"
        validation_errors = errors if not is_valid else None
        
        return ForgeResult(
            success=is_valid,
            data={
                "output_path": output_path,
                "validation_status": validation_status,
                "llm_model": llm_model  # Track which model was used (even if mocked)
            },
            errors=validation_errors
        )
            
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])
    
    


# AI-EDITABLE: forge.code.generate
def forge_code_generate_execute(
    input_semantic_path: str,
    target_language: str,
    template_directory: str,
    output_directory: str,
    files_generated: Optional[List[str]] = None,
) -> ForgeResult:
    """Generate code from semantic convention using Weaver
    
    Args:
        input_semantic_path: Path to semantic convention YAML file
        target_language: Target programming language for generation
        template_directory: Directory containing Weaver templates
        output_directory: Directory where generated code will be written
        files_generated: List of files generated
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # Wrap Weaver CLI for code generation
    try:
        # Validate inputs
        if not validate_file_exists(input_semantic_path):
            return ForgeResult(success=False, errors=[f"Semantic file not found: {input_semantic_path}"])
        
        if not Path(template_directory).exists():
            return ForgeResult(success=False, errors=[f"Template directory not found: {template_directory}"])
        
        # Use Weaver CLI to generate code
        generated_files = weaver_registry_generate(
            registry_path=input_semantic_path,
            target_name=target_language,
            template_path=template_directory,
            output_dir=output_directory
        )
        
        return ForgeResult(
            success=True,
            data={
                "files_generated": generated_files,
                "output_directory": output_directory
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])
    
    


# AI-EDITABLE: forge.self.improve
def forge_self_improve_execute(
    current_version: str,
    improvements: List[str],
    target_version: str,
    reference_depth: Optional[int] = None,
) -> ForgeResult:
    """Self-referential improvement of Weaver Forge
    
    Args:
        current_version: Current version of Forge being improved
        improvements: List of improvements being applied
        reference_depth: Depth of self-reference (how many times Forge generated itself)
        target_version: Target version after improvements
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # Self-improvement through regeneration
    try:
        # Step 1: Validate current version exists
        current_path = f"weaver_forge_v{current_version}.yaml"
        if not validate_file_exists(current_path):
            # Use the main weaver-forge.yaml as starting point
            current_path = "weaver-forge.yaml"
            if not validate_file_exists(current_path):
                return ForgeResult(success=False, errors=["No base semantic convention found"])
        
        # Step 2: Copy to new version (in real implementation, would apply improvements)
        target_path = f"weaver_forge_v{target_version}.yaml"
        content = read_file(current_path)
        
        # Apply improvements (placeholder - in real implementation would modify the YAML)
        improved_content = apply_improvements_to_yaml(content, improvements)
        write_file(target_path, improved_content)
        
        # Step 3: Regenerate templates and code from improved semantics
        if Path("templates/registry/python").exists():
            # Create a proper registry structure for the improved YAML
            registry_path = create_registry_structure(target_path)
            try:
                generated_files = weaver_registry_generate(
                    registry_path=registry_path,
                    target_name="python",
                    template_path="templates",
                    output_dir=f"generated/forge_v{target_version}"
                )
            finally:
                # Clean up temporary registry
                import shutil
                shutil.rmtree(registry_path.rsplit('/', 1)[0], ignore_errors=True)
            
            return ForgeResult(
                success=True,
                data={
                    "improved_semantic_path": target_path,
                    "generated_files": generated_files,
                    "reference_depth": (reference_depth or 0) + 1
                }
            )
        else:
            return ForgeResult(
                success=True,
                data={
                    "improved_semantic_path": target_path,
                    "reference_depth": (reference_depth or 0) + 1
                }
            )
            
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])
    
    



# Helper functions

def create_basic_semantic_convention(description: str, output_path: str) -> str:
    """Create a basic semantic convention YAML structure"""
    import yaml
    
    # Extract namespace from output path
    namespace = Path(output_path).stem.replace('_', '.')
    
    basic_structure = {
        "groups": [{
            "id": namespace,
            "type": "span",
            "brief": description,
            "stability": "experimental",
            "attributes": []
        }]
    }
    
    return yaml.dump(basic_structure, sort_keys=False, default_flow_style=False)

def apply_improvements_to_yaml(content: str, improvements: List[str]) -> str:
    """Apply improvements to YAML content (placeholder implementation)"""
    import yaml
    
    data = yaml.safe_load(content)
    
    # Add a note about improvements
    if 'groups' in data and len(data['groups']) > 0:
        data['groups'][0]['note'] = f"Improved with: {', '.join(improvements)}"
    
    return yaml.dump(data, sort_keys=False, default_flow_style=False)