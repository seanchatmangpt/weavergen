{
    "sourceFile": "src/weavergen/commands/weaver.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1751480695213,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1751480695213,
            "name": "Commit-0",
            "content": "\"\"\"Direct Weaver binary commands for WeaverGen v2.\"\"\"\n\nfrom pathlib import Path\nfrom typing import Optional, List\nimport typer\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.progress import Progress, SpinnerColumn, TextColumn\nimport json\nfrom opentelemetry import trace\nfrom opentelemetry.trace import Status, StatusCode\n\n# Import real Weaver integration\nfrom ..weaver_integration import (\n    WeaverIntegration, WeaverConfig, WeaverTarget,\n    WeaverValidationResult, WeaverGenerationResult, WeaverRegistryInfo\n)\n\n# Initialize CLI app and console\nweaver_app = typer.Typer(help=\"Direct Weaver binary commands\")\nconsole = Console()\ntracer = trace.get_tracer(__name__)\n\n# Initialize Weaver integration\n_weaver_integration = None\n\ndef get_weaver_integration():\n    \"\"\"Get or create Weaver integration instance.\"\"\"\n    global _weaver_integration\n    if _weaver_integration is None:\n        config = WeaverConfig(\n            weaver_path=Path(\"weaver\"),\n            templates_dir=Path(\"templates\"),\n            output_dir=Path(\"generated\"),\n            future_validation=True\n        )\n        _weaver_integration = WeaverIntegration(config)\n    return _weaver_integration\n\n\n@weaver_app.command()\ndef version():\n    \"\"\"Show Weaver version.\"\"\"\n    with tracer.start_as_current_span(\"weaver.version\") as span:\n        try:\n            weaver = get_weaver_integration()\n            version = weaver.get_weaver_version()\n            console.print(f\"[blue]Weaver version: {version}[/blue]\")\n            span.set_status(Status(StatusCode.OK))\n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@weaver_app.command()\ndef check(\n    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n    strict: bool = typer.Option(False, \"--strict\", \"-s\", help=\"Enable strict validation mode\"),\n    future: bool = typer.Option(True, \"--future\", \"-f\", help=\"Enable future validation rules\"),\n    quiet: bool = typer.Option(False, \"--quiet\", \"-q\", help=\"Quiet mode\")\n):\n    \"\"\"Validate a semantic convention registry using Weaver.\"\"\"\n    with tracer.start_as_current_span(\"weaver.check\") as span:\n        span.set_attribute(\"registry\", str(registry_path))\n        span.set_attribute(\"strict\", strict)\n        \n        try:\n            weaver = get_weaver_integration()\n            \n            # Configure validation mode\n            if strict:\n                weaver.config.future_validation = True\n            if future:\n                weaver.config.future_validation = True\n            if quiet:\n                weaver.config.quiet = True\n            \n            # Validate using real Weaver\n            result = weaver.check_registry(registry_path, strict=strict)\n            \n            # Display results\n            if result.valid:\n                console.print(\"[green]‚úì[/green] Registry validation passed!\")\n                \n                # Show warnings if any\n                if result.warnings and not quiet:\n                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n                    for warning in result.warnings:\n                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n                \n                span.set_status(Status(StatusCode.OK))\n            else:\n                console.print(\"[red]‚úó[/red] Validation errors found:\")\n                for error in result.errors:\n                    console.print(f\"  [red]‚Ä¢[/red] {error}\")\n                \n                # Show warnings too\n                if result.warnings and not quiet:\n                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n                    for warning in result.warnings:\n                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n                \n                span.set_status(Status(StatusCode.ERROR, f\"Validation failed: {len(result.errors)} errors\"))\n                raise typer.Exit(1)\n                \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@weaver_app.command()\ndef stats(\n    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n    json_output: bool = typer.Option(False, \"--json\", \"-j\", help=\"Output in JSON format\")\n):\n    \"\"\"Get detailed statistics about a semantic convention registry.\"\"\"\n    with tracer.start_as_current_span(\"weaver.stats\") as span:\n        span.set_attribute(\"registry\", str(registry_path))\n        \n        try:\n            weaver = get_weaver_integration()\n            \n            # Get registry statistics\n            stats = weaver.get_registry_stats(registry_path)\n            \n            if stats.valid:\n                if json_output:\n                    # Output as JSON\n                    output = {\n                        \"registry\": str(registry_path),\n                        \"valid\": stats.valid,\n                        \"groups\": stats.groups_count,\n                        \"attributes\": stats.attributes_count,\n                        \"metrics\": stats.metrics_count,\n                        \"spans\": stats.spans_count,\n                        \"resources\": stats.resources_count,\n                        \"detailed_stats\": stats.stats\n                    }\n                    console.print(json.dumps(output, indent=2))\n                else:\n                    # Pretty output\n                    console.print(f\"[blue]Registry Statistics for {registry_path.name}:[/blue]\\n\")\n                    \n                    # Display basic stats\n                    console.print(f\"üìä Groups: {stats.groups_count}\")\n                    console.print(f\"üè∑Ô∏è  Attributes: {stats.attributes_count}\")\n                    console.print(f\"üìà Metrics: {stats.metrics_count}\")\n                    console.print(f\"üîó Spans: {stats.spans_count}\")\n                    console.print(f\"üì¶ Resources: {stats.resources_count}\")\n                    \n                    # Display detailed stats if available\n                    if stats.stats:\n                        console.print(f\"\\n[blue]Detailed Statistics:[/blue]\")\n                        for key, value in stats.stats.items():\n                            if isinstance(value, (int, float)):\n                                console.print(f\"  ‚Ä¢ {key}: {value}\")\n                            elif isinstance(value, dict):\n                                console.print(f\"  ‚Ä¢ {key}:\")\n                                for sub_key, sub_value in value.items():\n                                    console.print(f\"    - {sub_key}: {sub_value}\")\n                \n                span.set_status(Status(StatusCode.OK))\n            else:\n                console.print(\"[red]Failed to get registry statistics[/red]\")\n                span.set_status(Status(StatusCode.ERROR, \"Stats failed\"))\n                raise typer.Exit(1)\n                \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@weaver_app.command()\ndef resolve(\n    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n    output_file: Optional[Path] = typer.Option(None, \"--output\", \"-o\", help=\"Output file for resolved registry\")\n):\n    \"\"\"Resolve a semantic convention registry to a single file.\"\"\"\n    with tracer.start_as_current_span(\"weaver.resolve\") as span:\n        span.set_attribute(\"registry\", str(registry_path))\n        \n        try:\n            weaver = get_weaver_integration()\n            \n            # Resolve registry\n            resolved_file = weaver.resolve_registry(registry_path, output_file)\n            \n            console.print(f\"[green]‚úì[/green] Registry resolved successfully!\")\n            console.print(f\"üìÅ Resolved file: {resolved_file}\")\n            \n            # Show file size\n            if resolved_file.exists():\n                size = resolved_file.stat().st_size\n                console.print(f\"üìè File size: {size:,} bytes\")\n            \n            span.set_status(Status(StatusCode.OK))\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@weaver_app.command()\ndef generate(\n    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n    target: str = typer.Option(\"codegen_python\", \"--target\", \"-t\", help=\"Generation target\"),\n    output_dir: Path = typer.Option(Path(\"./generated\"), \"--output\", \"-o\", help=\"Output directory\"),\n    templates_dir: Optional[Path] = typer.Option(None, \"--templates\", help=\"Templates directory\"),\n    parameters: Optional[List[str]] = typer.Option(None, \"--param\", \"-D\", help=\"Template parameters (key=value)\"),\n    policies: Optional[List[Path]] = typer.Option(None, \"--policy\", \"-p\", help=\"Policy files\"),\n    skip_policies: bool = typer.Option(False, \"--skip-policies\", help=\"Skip policy validation\"),\n    verbose: bool = typer.Option(False, \"--verbose\", \"-v\", help=\"Verbose output\")\n):\n    \"\"\"Generate artifacts from a semantic convention registry.\"\"\"\n    with tracer.start_as_current_span(\"weaver.generate\") as span:\n        span.set_attribute(\"registry\", str(registry_path))\n        span.set_attribute(\"target\", target)\n        \n        try:\n            weaver = get_weaver_integration()\n            \n            # Map target string to WeaverTarget enum\n            target_map = {\n                \"codegen_python\": WeaverTarget.CODE_GEN_PYTHON,\n                \"codegen_go\": WeaverTarget.CODE_GEN_GO,\n                \"codegen_rust\": WeaverTarget.CODE_GEN_RUST,\n                \"codegen_java\": WeaverTarget.CODE_GEN_JAVA,\n                \"codegen_typescript\": WeaverTarget.CODE_GEN_TYPESCRIPT,\n                \"codegen_dotnet\": WeaverTarget.CODE_GEN_DOTNET,\n                \"markdown\": WeaverTarget.MARKDOWN,\n                \"json_schema\": WeaverTarget.JSON_SCHEMA,\n                \"policy\": WeaverTarget.POLICY,\n            }\n            \n            weaver_target = target_map.get(target)\n            if not weaver_target:\n                console.print(f\"[red]Unsupported target: {target}[/red]\")\n                console.print(f\"Supported targets: {', '.join(target_map.keys())}\")\n                raise typer.Exit(1)\n            \n            # Parse parameters\n            params_dict = {}\n            if parameters:\n                for param in parameters:\n                    if \"=\" in param:\n                        key, value = param.split(\"=\", 1)\n                        params_dict[key] = value\n            \n            # Configure weaver\n            if verbose:\n                weaver.config.debug_level = 1\n            \n            with Progress(\n                SpinnerColumn(),\n                TextColumn(\"[progress.description]{task.description}\"),\n                console=console,\n            ) as progress:\n                # Validate first\n                progress.add_task(\"Validating registry...\", total=None)\n                validation_result = weaver.check_registry(registry_path, strict=False)\n                \n                if not validation_result.valid:\n                    console.print(\"[red]Validation failed![/red]\")\n                    for error in validation_result.errors:\n                        console.print(f\"  ‚Ä¢ {error}\")\n                    span.set_status(Status(StatusCode.ERROR, \"Validation failed\"))\n                    raise typer.Exit(1)\n                \n                # Generate\n                progress.add_task(f\"Generating {target}...\", total=None)\n                generation_result = weaver.generate_code(\n                    registry_path=registry_path,\n                    target=weaver_target,\n                    output_dir=output_dir,\n                    templates_dir=templates_dir,\n                    parameters=params_dict,\n                    policies=policies,\n                    skip_policies=skip_policies\n                )\n                \n                if generation_result.success:\n                    console.print(f\"[green]‚úì[/green] Generated {target} in {output_dir}\")\n                    \n                    # Show generated files\n                    if generation_result.generated_files:\n                        console.print(f\"\\n[blue]Generated files ({len(generation_result.generated_files)}):[/blue]\")\n                        for file in generation_result.generated_files[:10]:  # Show first 10\n                            console.print(f\"  ‚Ä¢ {file}\")\n                        if len(generation_result.generated_files) > 10:\n                            console.print(f\"  ‚Ä¢ ... and {len(generation_result.generated_files) - 10} more\")\n                    \n                    # Show diagnostics if any\n                    if generation_result.diagnostics and verbose:\n                        console.print(f\"\\n[yellow]Diagnostics ({len(generation_result.diagnostics)}):[/yellow]\")\n                        for diagnostic in generation_result.diagnostics[:5]:  # Show first 5\n                            if isinstance(diagnostic, dict):\n                                msg = diagnostic.get(\"message\", str(diagnostic))\n                                console.print(f\"  ‚Ä¢ {msg}\")\n                    \n                    span.set_status(Status(StatusCode.OK))\n                else:\n                    console.print(\"[red]Generation failed![/red]\")\n                    console.print(f\"Return code: {generation_result.return_code}\")\n                    if generation_result.stderr:\n                        console.print(f\"Error: {generation_result.stderr}\")\n                    span.set_status(Status(StatusCode.ERROR, f\"Generation failed: {generation_result.return_code}\"))\n                    raise typer.Exit(generation_result.return_code)\n                    \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@weaver_app.command()\ndef targets():\n    \"\"\"List available Weaver generation targets.\"\"\"\n    with tracer.start_as_current_span(\"weaver.targets\") as span:\n        try:\n            weaver = get_weaver_integration()\n            \n            # Get available targets\n            targets = weaver.get_available_targets()\n            \n            # Display targets\n            console.print(f\"[blue]Available Weaver Targets ({len(targets)}):[/blue]\\n\")\n            \n            table = Table(title=\"Weaver Generation Targets\")\n            table.add_column(\"Target\", style=\"cyan\")\n            table.add_column(\"Language/Type\", style=\"green\")\n            table.add_column(\"Description\", style=\"white\")\n            \n            for target in targets:\n                # Extract language from target name\n                lang = target.value.replace(\"codegen_\", \"\").title()\n                if lang == \"Json_schema\":\n                    lang = \"JSON Schema\"\n                elif lang == \"Gh_workflow_command\":\n                    lang = \"GitHub Workflow\"\n                \n                table.add_row(target.value, lang, f\"Generate {lang} from semantic conventions\")\n            \n            console.print(table)\n            \n            # Show Weaver version\n            version = weaver.get_weaver_version()\n            console.print(f\"\\n[dim]Weaver version: {version}[/dim]\")\n            \n            span.set_status(Status(StatusCode.OK))\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@weaver_app.command()\ndef init(\n    name: str = typer.Argument(..., help=\"Name of your semantic convention registry\"),\n    output_dir: Path = typer.Option(Path(\"./semantic_conventions\"), help=\"Output directory for semantic conventions\"),\n    with_examples: bool = typer.Option(True, help=\"Include example semantic convention files\")\n):\n    \"\"\"Initialize a new semantic convention registry with starter YAML files.\"\"\"\n    with tracer.start_as_current_span(\"weaver.init\") as span:\n        span.set_attribute(\"registry_name\", name)\n        span.set_attribute(\"output_dir\", str(output_dir))\n        \n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            span.set_attribute(\"weaver.version\", weaver.get_weaver_version())\n            \n            # Create output directory\n            output_dir.mkdir(parents=True, exist_ok=True)\n            \n            # Create registry manifest\n            manifest_file = output_dir / \"registry_manifest.yaml\"\n            manifest_content = f\"\"\"# WeaverGen Registry Manifest\nregistry:\n  name: {name}\n  version: \"1.0.0\"\n  description: \"Semantic convention registry for {name}\"\n  maintainers:\n    - name: \"WeaverGen\"\n      email: \"weavergen@example.com\"\n  \n  # Registry configuration\n  config:\n    future_validation: true\n    strict_mode: false\n    \n  # Dependencies\n  dependencies:\n    - url: \"https://github.com/open-telemetry/semantic-conventions.git[model]\"\n      version: \"main\"\n      \n  # Local semantic conventions\n  conventions:\n    - path: \"./model\"\n      description: \"Local semantic conventions\"\n\"\"\"\n            \n            manifest_file.write_text(manifest_content)\n            console.print(f\"[green]‚úì[/green] Created registry manifest: {manifest_file}\")\n            \n            # Create model directory\n            model_dir = output_dir / \"model\"\n            model_dir.mkdir(exist_ok=True)\n            \n            # Create example semantic conventions if requested\n            if with_examples:\n                example_file = model_dir / f\"{name}_common.yaml\"\n                example_content = f\"\"\"# {name} Common Semantic Conventions\ngroups:\n  - id: {name}.service\n    prefix: service\n    type: attribute_group\n    brief: 'Common service attributes for {name}'\n    attributes:\n      - id: name\n        type: string\n        requirement_level: required\n        brief: 'Service name'\n        examples: ['{name}-api', '{name}-worker']\n      - id: version\n        type: string\n        requirement_level: recommended\n        brief: 'Service version'\n        examples: ['1.0.0', '2.1.3']\n      - id: instance.id\n        type: string\n        requirement_level: recommended\n        brief: 'Service instance identifier'\n        examples: ['instance-1', 'pod-abc123']\n\n  - id: {name}.operation\n    prefix: operation\n    type: span\n    brief: 'Common operation attributes for {name}'\n    attributes:\n      - ref: {name}.service.name\n      - id: duration_ms\n        type: int\n        requirement_level: recommended\n        brief: 'Operation duration in milliseconds'\n      - id: status\n        type: string\n        requirement_level: required\n        brief: 'Operation status'\n        examples: ['success', 'failure', 'timeout']\n\"\"\"\n                \n                example_file.write_text(example_content)\n                console.print(f\"[green]‚úì[/green] Created example conventions: {example_file}\")\n            \n            # Validate the registry using Weaver\n            console.print(f\"\\n[blue]Validating registry with Weaver...[/blue]\")\n            validation_result = weaver.check_registry(output_dir, strict=False)\n            \n            if validation_result.valid:\n                console.print(\"[green]‚úì[/green] Registry validation passed!\")\n                \n                # Get registry statistics\n                stats = weaver.get_registry_stats(output_dir)\n                if stats.valid:\n                    console.print(f\"\\n[blue]Registry Statistics:[/blue]\")\n                    console.print(f\"  ‚Ä¢ Groups: {stats.groups_count}\")\n                    console.print(f\"  ‚Ä¢ Attributes: {stats.attributes_count}\")\n                    console.print(f\"  ‚Ä¢ Metrics: {stats.metrics_count}\")\n                    console.print(f\"  ‚Ä¢ Spans: {stats.spans_count}\")\n                    console.print(f\"  ‚Ä¢ Resources: {stats.resources_count}\")\n            else:\n                console.print(\"[yellow]‚ö†[/yellow] Registry validation warnings:\")\n                for warning in validation_result.warnings:\n                    console.print(f\"  ‚Ä¢ {warning}\")\n            \n            console.print(f\"\\n[green]‚úì[/green] Registry '{name}' initialized successfully!\")\n            console.print(f\"üìÅ Registry location: {output_dir.absolute()}\")\n            console.print(f\"üîß Weaver version: {weaver.get_weaver_version()}\")\n            \n            span.set_status(Status(StatusCode.OK))\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]FATAL: Registry initialization failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n\nif __name__ == \"__main__\":\n    weaver_app() "
        }
    ]
}