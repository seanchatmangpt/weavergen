# Generated by Weaver Forge - Commands Layer
# This layer provides thin interface wrappers with automatic telemetry
# DO NOT EDIT - This file is regenerated from semantic conventions

from opentelemetry import trace
from opentelemetry import metrics
from typing import Optional, Dict, Any, List
import functools
from dataclasses import dataclass

# Initialize telemetry
tracer = trace.get_tracer("weaver_forge")
meter = metrics.get_meter("weaver_forge")

# Metrics
operation_counter = meter.create_counter(
    "forge_operations_total",
    description="Total number of Forge operations",
    unit="1"
)

operation_duration = meter.create_histogram(
    "forge_operation_duration_seconds", 
    description="Duration of Forge operations",
    unit="s"
)

@dataclass
class ForgeResult:
    """Standard result type for Forge operations"""
    success: bool
    data: Optional[Any] = None
    errors: Optional[List[str]] = None

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    # Remove common prefixes
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")


def roberts_meeting_start(
    roberts_meeting_id: str,
    roberts_meeting_type: str,
    roberts_meeting_quorum: int,
    roberts_meeting_members_present: int,
    roberts_meeting_chair: str,
    roberts_meeting_secretary: str,
) -> ForgeResult:
    """Start a meeting following Robert's Rules
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        roberts_meeting_id: Unique identifier for the meeting
        roberts_meeting_type: Type of meeting being conducted
        roberts_meeting_quorum: Number of members required for quorum
        roberts_meeting_members_present: Current number of members present
        roberts_meeting_chair: Name or ID of the meeting chair
        roberts_meeting_secretary: Name or ID of the meeting secretary
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("roberts.meeting.start") as span:
        # Record span attributes
        
        span.set_attribute("roberts.meeting.id", roberts_meeting_id)
        
        span.set_attribute("roberts.meeting.type", roberts_meeting_type)
        
        span.set_attribute("roberts.meeting.quorum", roberts_meeting_quorum)
        
        span.set_attribute("roberts.meeting.members_present", roberts_meeting_members_present)
        
        span.set_attribute("roberts.meeting.chair", roberts_meeting_chair)
        
        span.set_attribute("roberts.meeting.secretary", roberts_meeting_secretary)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "roberts.meeting.start"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import roberts_meeting_start_execute
            
            # Call the operation
            result = roberts_meeting_start_execute(
                roberts_meeting_id=roberts_meeting_id,
                roberts_meeting_type=roberts_meeting_type,
                roberts_meeting_quorum=roberts_meeting_quorum,
                roberts_meeting_members_present=roberts_meeting_members_present,
                roberts_meeting_chair=roberts_meeting_chair,
                roberts_meeting_secretary=roberts_meeting_secretary,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def roberts_motion_make(
    roberts_motion_id: str,
    roberts_motion_type: str,
    roberts_motion_text: str,
    roberts_motion_mover: str,
    roberts_motion_requires_second: bool,
    roberts_motion_debatable: bool,
    roberts_motion_vote_required: str,
    roberts_motion_status: str,
    roberts_motion_seconder: Optional[str] = None,
) -> ForgeResult:
    """Make a motion according to Robert's Rules
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        roberts_motion_id: Unique identifier for the motion
        roberts_motion_type: Type of motion according to Robert's Rules
        roberts_motion_text: The full text of the motion
        roberts_motion_mover: Member who made the motion
        roberts_motion_seconder: Member who seconded the motion
        roberts_motion_requires_second: Whether this motion requires a second
        roberts_motion_debatable: Whether this motion is debatable
        roberts_motion_vote_required: Vote threshold required to pass
        roberts_motion_status: Current status of the motion
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("roberts.motion.make") as span:
        # Record span attributes
        
        span.set_attribute("roberts.motion.id", roberts_motion_id)
        
        span.set_attribute("roberts.motion.type", roberts_motion_type)
        
        span.set_attribute("roberts.motion.text", roberts_motion_text)
        
        span.set_attribute("roberts.motion.mover", roberts_motion_mover)
        
        if roberts_motion_seconder is not None:
            span.set_attribute("roberts.motion.seconder", roberts_motion_seconder)
        
        span.set_attribute("roberts.motion.requires_second", roberts_motion_requires_second)
        
        span.set_attribute("roberts.motion.debatable", roberts_motion_debatable)
        
        span.set_attribute("roberts.motion.vote_required", roberts_motion_vote_required)
        
        span.set_attribute("roberts.motion.status", roberts_motion_status)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "roberts.motion.make"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import roberts_motion_make_execute
            
            # Call the operation
            result = roberts_motion_make_execute(
                roberts_motion_id=roberts_motion_id,
                roberts_motion_type=roberts_motion_type,
                roberts_motion_text=roberts_motion_text,
                roberts_motion_mover=roberts_motion_mover,
                roberts_motion_requires_second=roberts_motion_requires_second,
                roberts_motion_debatable=roberts_motion_debatable,
                roberts_motion_vote_required=roberts_motion_vote_required,
                roberts_motion_status=roberts_motion_status,
                roberts_motion_seconder=roberts_motion_seconder,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def roberts_motion_second(
    roberts_motion_id: str,
    roberts_motion_type: str,
    roberts_motion_text: str,
    roberts_motion_mover: str,
    roberts_motion_requires_second: bool,
    roberts_motion_debatable: bool,
    roberts_motion_vote_required: str,
    roberts_motion_status: str,
    roberts_motion_seconder: Optional[str] = None,
) -> ForgeResult:
    """Second a motion
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        roberts_motion_id: Unique identifier for the motion
        roberts_motion_type: Type of motion according to Robert's Rules
        roberts_motion_text: The full text of the motion
        roberts_motion_mover: Member who made the motion
        roberts_motion_seconder: Member who seconded the motion
        roberts_motion_requires_second: Whether this motion requires a second
        roberts_motion_debatable: Whether this motion is debatable
        roberts_motion_vote_required: Vote threshold required to pass
        roberts_motion_status: Current status of the motion
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("roberts.motion.second") as span:
        # Record span attributes
        
        span.set_attribute("roberts.motion.id", roberts_motion_id)
        
        span.set_attribute("roberts.motion.type", roberts_motion_type)
        
        span.set_attribute("roberts.motion.text", roberts_motion_text)
        
        span.set_attribute("roberts.motion.mover", roberts_motion_mover)
        
        if roberts_motion_seconder is not None:
            span.set_attribute("roberts.motion.seconder", roberts_motion_seconder)
        
        span.set_attribute("roberts.motion.requires_second", roberts_motion_requires_second)
        
        span.set_attribute("roberts.motion.debatable", roberts_motion_debatable)
        
        span.set_attribute("roberts.motion.vote_required", roberts_motion_vote_required)
        
        span.set_attribute("roberts.motion.status", roberts_motion_status)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "roberts.motion.second"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import roberts_motion_second_execute
            
            # Call the operation
            result = roberts_motion_second_execute(
                roberts_motion_id=roberts_motion_id,
                roberts_motion_type=roberts_motion_type,
                roberts_motion_text=roberts_motion_text,
                roberts_motion_mover=roberts_motion_mover,
                roberts_motion_requires_second=roberts_motion_requires_second,
                roberts_motion_debatable=roberts_motion_debatable,
                roberts_motion_vote_required=roberts_motion_vote_required,
                roberts_motion_status=roberts_motion_status,
                roberts_motion_seconder=roberts_motion_seconder,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def roberts_vote_record(
    roberts_vote_motion_id: str,
    roberts_vote_method: str,
    roberts_vote_yes_count: int,
    roberts_vote_no_count: int,
    roberts_vote_result: str,
    roberts_vote_abstain_count: Optional[int] = None,
) -> ForgeResult:
    """Record vote on a motion
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        roberts_vote_motion_id: ID of the motion being voted on
        roberts_vote_method: Method of voting
        roberts_vote_yes_count: Number of yes votes
        roberts_vote_no_count: Number of no votes
        roberts_vote_abstain_count: Number of abstentions
        roberts_vote_result: Result of the vote
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("roberts.vote.record") as span:
        # Record span attributes
        
        span.set_attribute("roberts.vote.motion_id", roberts_vote_motion_id)
        
        span.set_attribute("roberts.vote.method", roberts_vote_method)
        
        span.set_attribute("roberts.vote.yes_count", roberts_vote_yes_count)
        
        span.set_attribute("roberts.vote.no_count", roberts_vote_no_count)
        
        if roberts_vote_abstain_count is not None:
            span.set_attribute("roberts.vote.abstain_count", roberts_vote_abstain_count)
        
        span.set_attribute("roberts.vote.result", roberts_vote_result)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "roberts.vote.record"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import roberts_vote_record_execute
            
            # Call the operation
            result = roberts_vote_record_execute(
                roberts_vote_motion_id=roberts_vote_motion_id,
                roberts_vote_method=roberts_vote_method,
                roberts_vote_yes_count=roberts_vote_yes_count,
                roberts_vote_no_count=roberts_vote_no_count,
                roberts_vote_result=roberts_vote_result,
                roberts_vote_abstain_count=roberts_vote_abstain_count,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def roberts_point_of_order_raise(
    roberts_point_of_order_member: str,
    roberts_point_of_order_issue: str,
    roberts_point_of_order_ruling: Optional[str] = None,
    roberts_point_of_order_appealed: Optional[bool] = None,
) -> ForgeResult:
    """Raise a point of order
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        roberts_point_of_order_member: Member raising the point of order
        roberts_point_of_order_issue: Description of the procedural issue
        roberts_point_of_order_ruling: Chair's ruling on the point
        roberts_point_of_order_appealed: Whether the ruling was appealed
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("roberts.point_of_order.raise") as span:
        # Record span attributes
        
        span.set_attribute("roberts.point_of_order.member", roberts_point_of_order_member)
        
        span.set_attribute("roberts.point_of_order.issue", roberts_point_of_order_issue)
        
        if roberts_point_of_order_ruling is not None:
            span.set_attribute("roberts.point_of_order.ruling", roberts_point_of_order_ruling)
        
        if roberts_point_of_order_appealed is not None:
            span.set_attribute("roberts.point_of_order.appealed", roberts_point_of_order_appealed)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "roberts.point_of_order.raise"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import roberts_point_of_order_raise_execute
            
            # Call the operation
            result = roberts_point_of_order_raise_execute(
                roberts_point_of_order_member=roberts_point_of_order_member,
                roberts_point_of_order_issue=roberts_point_of_order_issue,
                roberts_point_of_order_ruling=roberts_point_of_order_ruling,
                roberts_point_of_order_appealed=roberts_point_of_order_appealed,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def roberts_recognition_request(
    roberts_recognition_member: str,
    roberts_recognition_purpose: str,
    roberts_recognition_granted: bool,
    roberts_recognition_queue_position: Optional[int] = None,
) -> ForgeResult:
    """Request recognition to speak
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        roberts_recognition_member: Member seeking recognition
        roberts_recognition_purpose: Purpose of seeking recognition
        roberts_recognition_granted: Whether recognition was granted
        roberts_recognition_queue_position: Position in speaking queue
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("roberts.recognition.request") as span:
        # Record span attributes
        
        span.set_attribute("roberts.recognition.member", roberts_recognition_member)
        
        span.set_attribute("roberts.recognition.purpose", roberts_recognition_purpose)
        
        span.set_attribute("roberts.recognition.granted", roberts_recognition_granted)
        
        if roberts_recognition_queue_position is not None:
            span.set_attribute("roberts.recognition.queue_position", roberts_recognition_queue_position)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "roberts.recognition.request"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import roberts_recognition_request_execute
            
            # Call the operation
            result = roberts_recognition_request_execute(
                roberts_recognition_member=roberts_recognition_member,
                roberts_recognition_purpose=roberts_recognition_purpose,
                roberts_recognition_granted=roberts_recognition_granted,
                roberts_recognition_queue_position=roberts_recognition_queue_position,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])

