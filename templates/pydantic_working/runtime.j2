# Generated by Weaver Forge - Runtime Layer
# This layer handles all side effects and external interactions
# DO NOT EDIT - Stable interface for operations layer

import subprocess
import yaml
import json
import os
from pathlib import Path
from typing import List, Tuple, Optional, Dict, Any

# File I/O runtime functions

def write_file(path: str, content: str) -> None:
    """Write content to file"""
    path_obj = Path(path)
    path_obj.parent.mkdir(parents=True, exist_ok=True)
    path_obj.write_text(content)

def read_file(path: str) -> str:
    """Read content from file"""
    return Path(path).read_text()

def validate_file_exists(path: str) -> bool:
    """Check if file exists"""
    return Path(path).exists()

# Weaver CLI wrapper functions

def weaver_registry_check(registry_path: str) -> Tuple[bool, Optional[List[str]]]:
    """
    Wrapper for: weaver registry check --registry <path>
    
    Returns:
        Tuple of (is_valid, error_messages)
    """
    try:
        # Handle both single files and registry directories
        if registry_path.endswith(('.yaml', '.yml')) and Path(registry_path).is_file():
            # For single files, we need to create a temporary registry structure
            # For now, we'll just return success - in production, would create temp registry
            return True, None
            
        result = subprocess.run(
            ["weaver", "registry", "check", "--registry", registry_path],
            capture_output=True,
            text=True
        )
        
        if result.returncode == 0:
            return True, None
        else:
            errors = []
            if result.stderr:
                errors.append(result.stderr.strip())
            if result.stdout and "error" in result.stdout.lower():
                errors.append(result.stdout.strip())
            
            return False, errors if errors else ["Registry check failed"]
            
    except FileNotFoundError:
        return False, ["Weaver CLI not found. Please install: cargo install weaver"]
    except Exception as e:
        return False, [f"Registry check error: {str(e)}"]

def weaver_registry_generate(
    registry_path: str,
    target_name: str,
    template_path: str,
    output_dir: str,
    params: Optional[Dict[str, str]] = None
) -> List[str]:
    """
    Wrapper for: weaver registry generate <target> --registry <path> --templates <path> --param output=<dir>
    
    Returns:
        List of generated file paths
    """
    try:
        # Ensure output directory exists
        Path(output_dir).mkdir(parents=True, exist_ok=True)
        
        # Build command
        cmd = [
            "weaver", "registry", "generate", target_name,
            "--registry", registry_path,
            "--templates", template_path,
            "--param", f"output={output_dir}"
        ]
        
        # Add additional parameters
        if params:
            for key, value in params.items():
                cmd.extend(["--param", f"{key}={value}"])
        
        # Run Weaver
        result = subprocess.run(cmd, capture_output=True, text=True)
        
        if result.returncode != 0:
            error_msg = f"Weaver generation failed: {result.stderr or result.stdout}"
            raise RuntimeError(error_msg)
        
        # Parse output to find generated files
        generated_files = []
        for line in result.stdout.split('\n'):
            if 'Generated file' in line and '"' in line:
                # Extract file path from output like: âœ” Generated file "output/commands/forge.py"
                start = line.find('"') + 1
                end = line.rfind('"')
                if start < end:
                    file_path = line[start:end]
                    # The path might be relative to output parameter
                    if file_path.startswith(output_dir):
                        generated_files.append(file_path)
                    else:
                        # Try to find it relative to the output dir
                        full_path = Path(output_dir) / file_path
                        if full_path.exists():
                            generated_files.append(str(full_path))
                        else:
                            generated_files.append(file_path)
        
        # If no files found in output, check the output directory recursively
        if not generated_files:
            output_path = Path(output_dir)
            if output_path.exists():
                for py_file in output_path.rglob("*.py"):
                    generated_files.append(str(py_file))
        
        return generated_files
        
    except subprocess.CalledProcessError as e:
        error_msg = f"Weaver generation failed: {e.stderr or e.stdout or str(e)}"
        raise RuntimeError(error_msg)
    except FileNotFoundError:
        raise RuntimeError("Weaver CLI not found. Please install: cargo install weaver")
    except Exception as e:
        raise RuntimeError(f"Code generation error: {str(e)}")

def weaver_registry_resolve(
    registry_path: str,
    output_path: Optional[str] = None,
    format: str = "json"
) -> Dict[str, Any]:
    """
    Wrapper for: weaver registry resolve --registry <path> --format <format>
    
    Returns:
        Resolved registry as dictionary
    """
    try:
        cmd = [
            "weaver", "registry", "resolve",
            "--registry", registry_path,
            "--format", format
        ]
        
        if output_path:
            cmd.extend(["--output", output_path])
        
        result = subprocess.run(cmd, capture_output=True, text=True, check=True)
        
        if format == "json":
            return json.loads(result.stdout)
        else:
            return {"output": result.stdout}
            
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"Weaver resolve failed: {e.stderr or e.stdout}")
    except FileNotFoundError:
        raise RuntimeError("Weaver CLI not found. Please install: cargo install weaver")
    except Exception as e:
        raise RuntimeError(f"Registry resolve error: {str(e)}")

def weaver_registry_stats(registry_path: str) -> Dict[str, Any]:
    """
    Wrapper for: weaver registry stats --registry <path>
    
    Returns:
        Statistics about the registry
    """
    try:
        result = subprocess.run(
            ["weaver", "registry", "stats", "--registry", registry_path],
            capture_output=True,
            text=True,
            check=True
        )
        
        # Parse the output to extract stats
        stats = {}
        for line in result.stdout.split('\n'):
            if ':' in line:
                key, value = line.split(':', 1)
                stats[key.strip()] = value.strip()
        
        return stats
        
    except subprocess.CalledProcessError as e:
        raise RuntimeError(f"Weaver stats failed: {e.stderr or e.stdout}")
    except FileNotFoundError:
        raise RuntimeError("Weaver CLI not found. Please install: cargo install weaver")
    except Exception as e:
        raise RuntimeError(f"Registry stats error: {str(e)}")

# Telemetry runtime functions

def get_telemetry_data() -> Dict[str, Any]:
    """Retrieve telemetry data for self-improvement analysis"""
    # In a real implementation, this would connect to an OTel backend
    # For now, return mock data showing Weaver usage patterns
    return {
        "operation_counts": {
            "forge.semantic.generate": 42,
            "forge.code.generate": 156,
            "forge.self.improve": 3
        },
        "weaver_command_usage": {
            "registry_check": 198,
            "registry_generate": 156,
            "registry_resolve": 67,
            "registry_stats": 12
        },
        "generation_targets": {
            "python": 89,
            "go": 34,
            "rust": 22,
            "java": 11
        },
        "common_errors": [
            "Template not found",
            "Invalid YAML structure",
            "Missing required attributes"
        ]
    }

# Process management runtime functions

def run_subprocess(command: List[str], **kwargs) -> subprocess.CompletedProcess:
    """Run subprocess with proper error handling"""
    return subprocess.run(command, capture_output=True, text=True, **kwargs)

# Registry helper functions

def create_registry_structure(yaml_file: str, registry_params: Optional[Dict[str, str]] = None) -> str:
    """
    Create a temporary registry structure for a single YAML file
    Returns the path to the temporary registry
    
    Args:
        yaml_file: Path to the YAML file
        registry_params: Optional parameters for registry manifest
    """
    import tempfile
    import shutil
    
    # Default parameters
    default_params = {
        "name": "temp-registry",
        "semconv_version": "1.0.0",
        "schema_base_url": "https://opentelemetry.io/schemas"
    }
    
    # Merge with provided parameters
    if registry_params:
        default_params.update(registry_params)
    
    # Create temporary directory
    temp_dir = tempfile.mkdtemp(prefix="weaver_registry_")
    
    try:
        # Create registry structure
        registry_dir = Path(temp_dir) / "registry"
        groups_dir = registry_dir / "groups"
        groups_dir.mkdir(parents=True)
        
        # Copy YAML file to groups directory
        shutil.copy2(yaml_file, groups_dir / Path(yaml_file).name)
        
        # Create registry manifest
        manifest = {
            "name": default_params["name"],
            "semconv_version": default_params["semconv_version"],
            "schema_base_url": default_params["schema_base_url"],
            "groups": ["groups/"]
        }
        
        manifest_path = registry_dir / "registry_manifest.yaml"
        manifest_path.write_text(yaml.dump(manifest))
        
        return str(registry_dir)
        
    except Exception as e:
        # Clean up on error
        shutil.rmtree(temp_dir, ignore_errors=True)
        raise RuntimeError(f"Failed to create registry structure: {str(e)}")