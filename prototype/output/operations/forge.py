# Generated by Weaver Forge - Operations Layer
# AI-EDITABLE: This layer contains business logic that can be modified by AI
# The function signatures and contracts must be maintained

import os
from typing import Optional, List, Dict, Any
from pathlib import Path

# Import contracts and runtime
from contracts.forge import *
from runtime.forge import *

# Import the result type
from commands.forge import ForgeResult

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")


# AI-EDITABLE: weaver.registry.check
def weaver_registry_check_execute(
    registry_check_path: str,
    registry_check_valid: bool,
    registry_check_strict: Optional[bool] = None,
    registry_check_errors: Optional[List[str]] = None,
) -> ForgeResult:
    """Validate a semantic convention registry for correctness
    
    Args:
        registry_check_path: Path to the registry to check
        registry_check_strict: Enable strict validation mode
        registry_check_valid: Whether the registry passed validation
        registry_check_errors: List of validation errors if validation failed
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # AI-EDITABLE: Implementation using runtime layer
    try:
        # Call runtime layer to check registry
        is_valid, errors = weaver_registry_check(registry_check_path)
        
        return ForgeResult(
            success=is_valid,
            data={"valid": is_valid, "strict": registry_check_strict},
            errors=errors
        )
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])
    
    


# AI-EDITABLE: weaver.registry.generate
def weaver_registry_generate_execute(
    registry_generate_registry_path: str,
    registry_generate_target: str,
    registry_generate_output_dir: str,
    registry_generate_files_count: int,
    registry_generate_template_path: Optional[str] = None,
    registry_generate_params: Optional[Dict[str, str]] = None,
    registry_generate_files: Optional[List[str]] = None,
) -> ForgeResult:
    """Generate code or documentation from a semantic convention registry
    
    Args:
        registry_generate_registry_path: Path to the semantic convention registry
        registry_generate_target: Target language or format for generation
        registry_generate_template_path: Path to custom templates
        registry_generate_output_dir: Output directory for generated files
        registry_generate_params: Additional parameters passed to templates
        registry_generate_files_count: Number of files generated
        registry_generate_files: List of generated file paths
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # AI-EDITABLE: Implementation using runtime layer
    try:
        # Call runtime layer to generate code
        files = weaver_registry_generate(
            registry_path=registry_generate_registry_path,
            target_name=registry_generate_target,
            template_path=registry_generate_template_path or "templates",
            output_dir=registry_generate_output_dir,
            params=registry_generate_params
        )
        
        return ForgeResult(
            success=True,
            data={
                "files": files,
                "files_count": len(files),
                "target": registry_generate_target,
                "output_dir": registry_generate_output_dir
            }
        )
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])
    
    


# AI-EDITABLE: weaver.registry.resolve
def weaver_registry_resolve_execute(
    registry_resolve_registry_path: str,
    registry_resolve_groups_count: int,
    registry_resolve_format: Optional[str] = None,
    registry_resolve_output_path: Optional[str] = None,
) -> ForgeResult:
    """Resolve references and merge semantic conventions
    
    Args:
        registry_resolve_registry_path: Path to the registry to resolve
        registry_resolve_format: Output format for resolved registry
        registry_resolve_output_path: Path to write resolved output
        registry_resolve_groups_count: Number of groups in resolved registry
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # AI-EDITABLE: Implement this operation
    return ForgeResult(success=False, errors=["Operation not implemented"])
    
    


# AI-EDITABLE: weaver.registry.stats
def weaver_registry_stats_execute(
    registry_stats_registry_path: str,
    registry_stats_total_groups: int,
    registry_stats_total_attributes: int,
    registry_stats_stable_count: Optional[int] = None,
    registry_stats_experimental_count: Optional[int] = None,
) -> ForgeResult:
    """Generate statistics about a semantic convention registry
    
    Args:
        registry_stats_registry_path: Path to the registry
        registry_stats_total_groups: Total number of groups
        registry_stats_total_attributes: Total number of attributes
        registry_stats_stable_count: Number of stable definitions
        registry_stats_experimental_count: Number of experimental definitions
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # AI-EDITABLE: Implement this operation
    return ForgeResult(success=False, errors=["Operation not implemented"])
    
    


# AI-EDITABLE: weaver.multi.generate
def weaver_multi_generate_execute(
    multi_generate_registry_path: str,
    multi_generate_languages: List[str],
    multi_generate_total_files: int,
    multi_generate_parallel: Optional[bool] = None,
    multi_generate_duration_ms: Optional[int] = None,
) -> ForgeResult:
    """Generate code for multiple languages in parallel
    
    Args:
        multi_generate_registry_path: Path to the registry
        multi_generate_languages: List of target languages
        multi_generate_parallel: Whether to generate in parallel
        multi_generate_total_files: Total files generated across all languages
        multi_generate_duration_ms: Total duration in milliseconds
        
    Returns:
        ForgeResult with success status and relevant data
    """
    
    # AI-EDITABLE: Implement this operation
    return ForgeResult(success=False, errors=["Operation not implemented"])
    
    



# Helper functions

def create_basic_semantic_convention(description: str, output_path: str) -> str:
    """Create a basic semantic convention YAML structure"""
    import yaml
    
    # Extract namespace from output path
    namespace = Path(output_path).stem.replace('_', '.')
    
    basic_structure = {
        "groups": [{
            "id": namespace,
            "type": "span",
            "brief": description,
            "stability": "experimental",
            "attributes": []
        }]
    }
    
    return yaml.dump(basic_structure, sort_keys=False, default_flow_style=False)

def apply_improvements_to_yaml(content: str, improvements: List[str]) -> str:
    """Apply improvements to YAML content (placeholder implementation)"""
    import yaml
    
    data = yaml.safe_load(content)
    
    # Add a note about improvements
    if 'groups' in data and len(data['groups']) > 0:
        data['groups'][0]['note'] = f"Improved with: {', '.join(improvements)}"
    
    return yaml.dump(data, sort_keys=False, default_flow_style=False)