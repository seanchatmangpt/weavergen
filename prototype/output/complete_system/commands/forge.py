# Generated by Weaver Forge - Commands Layer
# This layer provides thin interface wrappers with automatic telemetry
# DO NOT EDIT - This file is regenerated from semantic conventions

from opentelemetry import trace
from opentelemetry import metrics
from typing import Optional, Dict, Any, List
import functools
from dataclasses import dataclass

# Initialize telemetry
tracer = trace.get_tracer("weaver_forge")
meter = metrics.get_meter("weaver_forge")

# Metrics
operation_counter = meter.create_counter(
    "forge_operations_total",
    description="Total number of Forge operations",
    unit="1"
)

operation_duration = meter.create_histogram(
    "forge_operation_duration_seconds", 
    description="Duration of Forge operations",
    unit="s"
)

@dataclass
class ForgeResult:
    """Standard result type for Forge operations"""
    success: bool
    data: Optional[Any] = None
    errors: Optional[List[str]] = None

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    # Remove common prefixes
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")


def agent(
    agent_id: str,
    agent_name: str,
    agent_role: str,
    agent_expertise: Optional[List[str]] = None,
    agent_status: Optional[{"members": [{"brief": none, "deprecated": none, "id": "active", "note": none, "stability": none, "value": "active"}, {"brief": none, "deprecated": none, "id": "idle", "note": none, "stability": none, "value": "idle"}, {"brief": none, "deprecated": none, "id": "busy", "note": none, "stability": none, "value": "busy"}, {"brief": none, "deprecated": none, "id": "offline", "note": none, "stability": none, "value": "offline"}]}] = None,
) -> ForgeResult:
    """AI agent participating in distributed systems
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        agent_id: Unique identifier for the agent
        agent_name: Human-readable name of the agent
        agent_role: Role or position of the agent
        agent_expertise: Areas of expertise for the agent
        agent_status: Current status of the agent
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("agent") as span:
        # Record span attributes
        
        span.set_attribute("agent.id", agent_id)
        
        span.set_attribute("agent.name", agent_name)
        
        span.set_attribute("agent.role", agent_role)
        
        if agent_expertise is not None:
            span.set_attribute("agent.expertise", agent_expertise)
        
        if agent_status is not None:
            span.set_attribute("agent.status", agent_status)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "agent"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import agent_execute
            
            # Call the operation
            result = agent_execute(
                agent_id=agent_id,
                agent_name=agent_name,
                agent_role=agent_role,
                agent_expertise=agent_expertise,
                agent_status=agent_status,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def otel_communication(
    otel_communication_message_id: str,
    otel_communication_sender: str,
    otel_communication_recipient: str,
    otel_communication_message_type: {"members": [{"brief": none, "deprecated": none, "id": "statement", "note": none, "stability": none, "value": "statement"}, {"brief": none, "deprecated": none, "id": "motion", "note": none, "stability": none, "value": "motion"}, {"brief": none, "deprecated": none, "id": "second", "note": none, "stability": none, "value": "second"}, {"brief": none, "deprecated": none, "id": "vote", "note": none, "stability": none, "value": "vote"}, {"brief": none, "deprecated": none, "id": "point_of_order", "note": none, "stability": none, "value": "point_of_order"}, {"brief": none, "deprecated": none, "id": "recognition_request", "note": none, "stability": none, "value": "recognition_request"}, {"brief": none, "deprecated": none, "id": "grant_recognition", "note": none, "stability": none, "value": "grant_recognition"}, {"brief": none, "deprecated": none, "id": "report", "note": none, "stability": none, "value": "report"}]},
    otel_communication_content: str,
    otel_communication_trace_id: str,
    otel_communication_span_id: str,
    otel_communication_parent_span_id: Optional[str] = None,
) -> ForgeResult:
    """OpenTelemetry-based communication between agents
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        otel_communication_message_id: Unique identifier for the message
        otel_communication_sender: Agent ID of the message sender
        otel_communication_recipient: Agent ID of recipient or 'all' for broadcast
        otel_communication_message_type: Type of message being sent
        otel_communication_content: The actual message content
        otel_communication_trace_id: OpenTelemetry trace ID for correlation
        otel_communication_span_id: OpenTelemetry span ID for this message
        otel_communication_parent_span_id: Parent span ID for message hierarchy
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("otel.communication") as span:
        # Record span attributes
        
        span.set_attribute("otel.communication.message_id", otel_communication_message_id)
        
        span.set_attribute("otel.communication.sender", otel_communication_sender)
        
        span.set_attribute("otel.communication.recipient", otel_communication_recipient)
        
        span.set_attribute("otel.communication.message_type", otel_communication_message_type)
        
        span.set_attribute("otel.communication.content", otel_communication_content)
        
        span.set_attribute("otel.communication.trace_id", otel_communication_trace_id)
        
        span.set_attribute("otel.communication.span_id", otel_communication_span_id)
        
        if otel_communication_parent_span_id is not None:
            span.set_attribute("otel.communication.parent_span_id", otel_communication_parent_span_id)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "otel.communication"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import otel_communication_execute
            
            # Call the operation
            result = otel_communication_execute(
                otel_communication_message_id=otel_communication_message_id,
                otel_communication_sender=otel_communication_sender,
                otel_communication_recipient=otel_communication_recipient,
                otel_communication_message_type=otel_communication_message_type,
                otel_communication_content=otel_communication_content,
                otel_communication_trace_id=otel_communication_trace_id,
                otel_communication_span_id=otel_communication_span_id,
                otel_communication_parent_span_id=otel_communication_parent_span_id,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def roberts_enhanced(
    roberts_enhanced_meeting_id: str,
    roberts_enhanced_meeting_type: {"members": [{"brief": none, "deprecated": none, "id": "board", "note": none, "stability": none, "value": "board"}, {"brief": none, "deprecated": none, "id": "committee", "note": none, "stability": none, "value": "committee"}, {"brief": none, "deprecated": none, "id": "development", "note": none, "stability": none, "value": "development"}, {"brief": none, "deprecated": none, "id": "scrum_of_scrums", "note": none, "stability": none, "value": "scrum_of_scrums"}]},
    roberts_enhanced_trace_context: Dict[str, str],
    roberts_enhanced_communication_mode: {"members": [{"brief": none, "deprecated": none, "id": "otel_spans", "note": none, "stability": none, "value": "otel_spans"}, {"brief": none, "deprecated": none, "id": "direct", "note": none, "stability": none, "value": "direct"}, {"brief": none, "deprecated": none, "id": "hybrid", "note": none, "stability": none, "value": "hybrid"}]},
) -> ForgeResult:
    """Enhanced Roberts Rules with OTel integration
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        roberts_enhanced_meeting_id: Unique meeting identifier
        roberts_enhanced_meeting_type: Type of meeting
        roberts_enhanced_trace_context: OpenTelemetry trace context for the meeting
        roberts_enhanced_communication_mode: How agents communicate
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("roberts.enhanced") as span:
        # Record span attributes
        
        span.set_attribute("roberts.enhanced.meeting_id", roberts_enhanced_meeting_id)
        
        span.set_attribute("roberts.enhanced.meeting_type", roberts_enhanced_meeting_type)
        
        span.set_attribute("roberts.enhanced.trace_context", roberts_enhanced_trace_context)
        
        span.set_attribute("roberts.enhanced.communication_mode", roberts_enhanced_communication_mode)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "roberts.enhanced"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import roberts_enhanced_execute
            
            # Call the operation
            result = roberts_enhanced_execute(
                roberts_enhanced_meeting_id=roberts_enhanced_meeting_id,
                roberts_enhanced_meeting_type=roberts_enhanced_meeting_type,
                roberts_enhanced_trace_context=roberts_enhanced_trace_context,
                roberts_enhanced_communication_mode=roberts_enhanced_communication_mode,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def motion_otel(
    motion_otel_id: str,
    motion_otel_trace_id: str,
    motion_otel_proposer_span_id: str,
    motion_otel_seconder_span_ids: Optional[List[str]] = None,
    motion_otel_vote_span_ids: Optional[Dict[str, str]] = None,
    motion_otel_discussion_span_ids: Optional[List[str]] = None,
) -> ForgeResult:
    """Parliamentary motion with OpenTelemetry tracking
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        motion_otel_id: Unique motion identifier
        motion_otel_trace_id: OTel trace ID when motion was made
        motion_otel_proposer_span_id: Span ID of the proposer's message
        motion_otel_seconder_span_ids: Span IDs of seconding messages
        motion_otel_vote_span_ids: Map of agent ID to vote span ID
        motion_otel_discussion_span_ids: Span IDs of discussion messages
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("motion.otel") as span:
        # Record span attributes
        
        span.set_attribute("motion.otel.id", motion_otel_id)
        
        span.set_attribute("motion.otel.trace_id", motion_otel_trace_id)
        
        span.set_attribute("motion.otel.proposer_span_id", motion_otel_proposer_span_id)
        
        if motion_otel_seconder_span_ids is not None:
            span.set_attribute("motion.otel.seconder_span_ids", motion_otel_seconder_span_ids)
        
        if motion_otel_vote_span_ids is not None:
            span.set_attribute("motion.otel.vote_span_ids", motion_otel_vote_span_ids)
        
        if motion_otel_discussion_span_ids is not None:
            span.set_attribute("motion.otel.discussion_span_ids", motion_otel_discussion_span_ids)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "motion.otel"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import motion_otel_execute
            
            # Call the operation
            result = motion_otel_execute(
                motion_otel_id=motion_otel_id,
                motion_otel_trace_id=motion_otel_trace_id,
                motion_otel_proposer_span_id=motion_otel_proposer_span_id,
                motion_otel_seconder_span_ids=motion_otel_seconder_span_ids,
                motion_otel_vote_span_ids=motion_otel_vote_span_ids,
                motion_otel_discussion_span_ids=motion_otel_discussion_span_ids,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def agent_file_analysis(
    agent_file_analysis_agent_id: str,
    agent_file_analysis_file_path: str,
    agent_file_analysis_insights: List[str],
    agent_file_analysis_file_hash: Optional[str] = None,
    agent_file_analysis_patterns_found: Optional[template[int]] = None,
) -> ForgeResult:
    """Agent's analysis of project files
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        agent_file_analysis_agent_id: Agent performing the analysis
        agent_file_analysis_file_path: Path to the analyzed file
        agent_file_analysis_file_hash: Hash of file contents for versioning
        agent_file_analysis_insights: Insights discovered by the agent
        agent_file_analysis_patterns_found: Count of various patterns found
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("agent.file_analysis") as span:
        # Record span attributes
        
        span.set_attribute("agent.file_analysis.agent_id", agent_file_analysis_agent_id)
        
        span.set_attribute("agent.file_analysis.file_path", agent_file_analysis_file_path)
        
        if agent_file_analysis_file_hash is not None:
            span.set_attribute("agent.file_analysis.file_hash", agent_file_analysis_file_hash)
        
        span.set_attribute("agent.file_analysis.insights", agent_file_analysis_insights)
        
        if agent_file_analysis_patterns_found is not None:
            span.set_attribute("agent.file_analysis.patterns_found", agent_file_analysis_patterns_found)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "agent.file_analysis"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import agent_file_analysis_execute
            
            # Call the operation
            result = agent_file_analysis_execute(
                agent_file_analysis_agent_id=agent_file_analysis_agent_id,
                agent_file_analysis_file_path=agent_file_analysis_file_path,
                agent_file_analysis_insights=agent_file_analysis_insights,
                agent_file_analysis_file_hash=agent_file_analysis_file_hash,
                agent_file_analysis_patterns_found=agent_file_analysis_patterns_found,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def validation_concurrent(
    validation_concurrent_layer: {"members": [{"brief": none, "deprecated": none, "id": "commands", "note": none, "stability": none, "value": "commands"}, {"brief": none, "deprecated": none, "id": "operations", "note": none, "stability": none, "value": "operations"}, {"brief": none, "deprecated": none, "id": "runtime", "note": none, "stability": none, "value": "runtime"}, {"brief": none, "deprecated": none, "id": "contracts", "note": none, "stability": none, "value": "contracts"}]},
    validation_concurrent_start_time: str,
    validation_concurrent_duration_ms: float,
    validation_concurrent_files_checked: int,
    validation_concurrent_issues_found: int,
    validation_concurrent_success: bool,
) -> ForgeResult:
    """Concurrent validation of system layers
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        validation_concurrent_layer: Which layer is being validated
        validation_concurrent_start_time: ISO timestamp when validation started
        validation_concurrent_duration_ms: Duration of validation in milliseconds
        validation_concurrent_files_checked: Number of files validated
        validation_concurrent_issues_found: Number of validation issues found
        validation_concurrent_success: Whether validation passed
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("validation.concurrent") as span:
        # Record span attributes
        
        span.set_attribute("validation.concurrent.layer", validation_concurrent_layer)
        
        span.set_attribute("validation.concurrent.start_time", validation_concurrent_start_time)
        
        span.set_attribute("validation.concurrent.duration_ms", validation_concurrent_duration_ms)
        
        span.set_attribute("validation.concurrent.files_checked", validation_concurrent_files_checked)
        
        span.set_attribute("validation.concurrent.issues_found", validation_concurrent_issues_found)
        
        span.set_attribute("validation.concurrent.success", validation_concurrent_success)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "validation.concurrent"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import validation_concurrent_execute
            
            # Call the operation
            result = validation_concurrent_execute(
                validation_concurrent_layer=validation_concurrent_layer,
                validation_concurrent_start_time=validation_concurrent_start_time,
                validation_concurrent_duration_ms=validation_concurrent_duration_ms,
                validation_concurrent_files_checked=validation_concurrent_files_checked,
                validation_concurrent_issues_found=validation_concurrent_issues_found,
                validation_concurrent_success=validation_concurrent_success,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def dev_team_meeting(
    dev_team_meeting_feature_proposed: str,
    dev_team_meeting_files_analyzed: int,
    dev_team_meeting_decisions: List[str],
    dev_team_meeting_action_items: Dict[str, str],
    dev_team_meeting_otel_spans_created: Optional[int] = None,
) -> ForgeResult:
    """Development team meeting with code analysis
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        dev_team_meeting_feature_proposed: Feature being discussed
        dev_team_meeting_files_analyzed: Total files analyzed by all agents
        dev_team_meeting_decisions: Decisions made during meeting
        dev_team_meeting_action_items: Action items assigned to agents
        dev_team_meeting_otel_spans_created: Number of OTel spans created during meeting
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("dev_team.meeting") as span:
        # Record span attributes
        
        span.set_attribute("dev_team.meeting.feature_proposed", dev_team_meeting_feature_proposed)
        
        span.set_attribute("dev_team.meeting.files_analyzed", dev_team_meeting_files_analyzed)
        
        span.set_attribute("dev_team.meeting.decisions", dev_team_meeting_decisions)
        
        span.set_attribute("dev_team.meeting.action_items", dev_team_meeting_action_items)
        
        if dev_team_meeting_otel_spans_created is not None:
            span.set_attribute("dev_team.meeting.otel_spans_created", dev_team_meeting_otel_spans_created)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "dev_team.meeting"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import dev_team_meeting_execute
            
            # Call the operation
            result = dev_team_meeting_execute(
                dev_team_meeting_feature_proposed=dev_team_meeting_feature_proposed,
                dev_team_meeting_files_analyzed=dev_team_meeting_files_analyzed,
                dev_team_meeting_decisions=dev_team_meeting_decisions,
                dev_team_meeting_action_items=dev_team_meeting_action_items,
                dev_team_meeting_otel_spans_created=dev_team_meeting_otel_spans_created,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def scrum_scale(
    scrum_scale_team_name: str,
    scrum_scale_scrum_master: str,
    scrum_scale_sprint_number: int,
    scrum_scale_completion_percent: float,
    scrum_scale_story_points_complete: int,
    scrum_scale_story_points_total: int,
    scrum_scale_impediments: Optional[List[str]] = None,
    scrum_scale_dependencies: Optional[Dict[str, str]] = None,
) -> ForgeResult:
    """Scrum of Scrums using Roberts Rules
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        scrum_scale_team_name: Name of the scrum team
        scrum_scale_scrum_master: Scrum master agent ID
        scrum_scale_sprint_number: Current sprint number
        scrum_scale_completion_percent: Sprint completion percentage
        scrum_scale_story_points_complete: Story points completed
        scrum_scale_story_points_total: Total story points in sprint
        scrum_scale_impediments: Current impediments
        scrum_scale_dependencies: Dependencies on other teams
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("scrum.scale") as span:
        # Record span attributes
        
        span.set_attribute("scrum.scale.team_name", scrum_scale_team_name)
        
        span.set_attribute("scrum.scale.scrum_master", scrum_scale_scrum_master)
        
        span.set_attribute("scrum.scale.sprint_number", scrum_scale_sprint_number)
        
        span.set_attribute("scrum.scale.completion_percent", scrum_scale_completion_percent)
        
        span.set_attribute("scrum.scale.story_points_complete", scrum_scale_story_points_complete)
        
        span.set_attribute("scrum.scale.story_points_total", scrum_scale_story_points_total)
        
        if scrum_scale_impediments is not None:
            span.set_attribute("scrum.scale.impediments", scrum_scale_impediments)
        
        if scrum_scale_dependencies is not None:
            span.set_attribute("scrum.scale.dependencies", scrum_scale_dependencies)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "scrum.scale"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import scrum_scale_execute
            
            # Call the operation
            result = scrum_scale_execute(
                scrum_scale_team_name=scrum_scale_team_name,
                scrum_scale_scrum_master=scrum_scale_scrum_master,
                scrum_scale_sprint_number=scrum_scale_sprint_number,
                scrum_scale_completion_percent=scrum_scale_completion_percent,
                scrum_scale_story_points_complete=scrum_scale_story_points_complete,
                scrum_scale_story_points_total=scrum_scale_story_points_total,
                scrum_scale_impediments=scrum_scale_impediments,
                scrum_scale_dependencies=scrum_scale_dependencies,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def quine_validation(
    quine_validation_semantic_file: str,
    quine_validation_generated_files: List[str],
    quine_validation_can_regenerate: bool,
    quine_validation_layers_validated: int,
    quine_validation_regeneration_hash: Optional[str] = None,
) -> ForgeResult:
    """Validation of semantic quine properties
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        quine_validation_semantic_file: Path to semantic convention file
        quine_validation_generated_files: Files generated from semantics
        quine_validation_can_regenerate: Whether system can regenerate itself
        quine_validation_regeneration_hash: Hash of regenerated code for comparison
        quine_validation_layers_validated: Number of architecture layers validated
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("quine.validation") as span:
        # Record span attributes
        
        span.set_attribute("quine.validation.semantic_file", quine_validation_semantic_file)
        
        span.set_attribute("quine.validation.generated_files", quine_validation_generated_files)
        
        span.set_attribute("quine.validation.can_regenerate", quine_validation_can_regenerate)
        
        if quine_validation_regeneration_hash is not None:
            span.set_attribute("quine.validation.regeneration_hash", quine_validation_regeneration_hash)
        
        span.set_attribute("quine.validation.layers_validated", quine_validation_layers_validated)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "quine.validation"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import quine_validation_execute
            
            # Call the operation
            result = quine_validation_execute(
                quine_validation_semantic_file=quine_validation_semantic_file,
                quine_validation_generated_files=quine_validation_generated_files,
                quine_validation_can_regenerate=quine_validation_can_regenerate,
                quine_validation_layers_validated=quine_validation_layers_validated,
                quine_validation_regeneration_hash=quine_validation_regeneration_hash,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def benchmark_ollama(
    benchmark_ollama_model: str,
    benchmark_ollama_gpu_enabled: bool,
    benchmark_ollama_tokens_generated: int,
    benchmark_ollama_tokens_per_second: float,
    benchmark_ollama_response_time_ms: float,
    benchmark_ollama_gpu_layers: Optional[int] = None,
    benchmark_ollama_metal_active: Optional[bool] = None,
) -> ForgeResult:
    """Benchmarking Ollama/LLM performance
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        benchmark_ollama_model: Model being benchmarked
        benchmark_ollama_gpu_enabled: Whether GPU acceleration is active
        benchmark_ollama_gpu_layers: Number of layers on GPU
        benchmark_ollama_tokens_generated: Total tokens generated
        benchmark_ollama_tokens_per_second: Token generation speed
        benchmark_ollama_response_time_ms: Total response time in milliseconds
        benchmark_ollama_metal_active: Whether Metal acceleration is active (macOS)
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("benchmark.ollama") as span:
        # Record span attributes
        
        span.set_attribute("benchmark.ollama.model", benchmark_ollama_model)
        
        span.set_attribute("benchmark.ollama.gpu_enabled", benchmark_ollama_gpu_enabled)
        
        if benchmark_ollama_gpu_layers is not None:
            span.set_attribute("benchmark.ollama.gpu_layers", benchmark_ollama_gpu_layers)
        
        span.set_attribute("benchmark.ollama.tokens_generated", benchmark_ollama_tokens_generated)
        
        span.set_attribute("benchmark.ollama.tokens_per_second", benchmark_ollama_tokens_per_second)
        
        span.set_attribute("benchmark.ollama.response_time_ms", benchmark_ollama_response_time_ms)
        
        if benchmark_ollama_metal_active is not None:
            span.set_attribute("benchmark.ollama.metal_active", benchmark_ollama_metal_active)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "benchmark.ollama"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import benchmark_ollama_execute
            
            # Call the operation
            result = benchmark_ollama_execute(
                benchmark_ollama_model=benchmark_ollama_model,
                benchmark_ollama_gpu_enabled=benchmark_ollama_gpu_enabled,
                benchmark_ollama_tokens_generated=benchmark_ollama_tokens_generated,
                benchmark_ollama_tokens_per_second=benchmark_ollama_tokens_per_second,
                benchmark_ollama_response_time_ms=benchmark_ollama_response_time_ms,
                benchmark_ollama_gpu_layers=benchmark_ollama_gpu_layers,
                benchmark_ollama_metal_active=benchmark_ollama_metal_active,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])

