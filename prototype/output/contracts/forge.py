# Generated by Weaver Forge - Contracts Layer
# Contract definitions using icontract for runtime validation
# DO NOT EDIT - Generated from semantic conventions

import icontract
from typing import Optional, List, Any
from pathlib import Path

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")

# Precondition validators

def valid_file_path(path: str) -> bool:
    """Check if file path is valid (parent directory exists)"""
    return Path(path).parent.exists() or not Path(path).parent.as_posix()

def valid_semantic_path(path: str) -> bool:
    """Check if semantic file exists and is readable"""
    return Path(path).exists() and Path(path).suffix in ['.yaml', '.yml']

def valid_directory_path(path: str) -> bool:
    """Check if directory path is valid"""
    try:
        Path(path).mkdir(parents=True, exist_ok=True)
        return True
    except Exception:
        return False

def valid_language(language: str) -> bool:
    """Check if target language is supported"""
    return language in ['python', 'go', 'rust', 'java', 'typescript']

def valid_model(model: str) -> bool:
    """Check if LLM model is supported"""
    return model in ['llama3.2', 'gpt-4', 'mistral', 'codellama']

def valid_version(version: str) -> bool:
    """Check if version string is valid (x.y.z format)"""
    parts = version.split('.')
    return len(parts) == 3 and all(p.isdigit() for p in parts)

# Postcondition validators

def file_was_created(path: str) -> bool:
    """Check if file was created successfully"""
    return Path(path).exists()

def files_were_generated(file_list: Optional[List[str]]) -> bool:
    """Check if all expected files were generated"""
    if not file_list:
        return False
    return all(Path(f).exists() for f in file_list)

# Contract decorators for operations


# Contracts for weaver.registry.check
class WeaverRegistryCheckContracts:
    """Contract definitions for weaver.registry.check"""
    
    
    @staticmethod
    def require_registry_check_path(registry_check_path: str) -> bool:
        """Path to the registry to check - Required"""
        return isinstance(registry_check_path, str) and len(registry_check_path) > 0
    
    
    @staticmethod
    def require_registry_check_valid(registry_check_valid: bool) -> bool:
        """Whether the registry passed validation - Required"""
        return True  # Default validation
    
    
    
    
    # Default contracts
    preconditions = []
    postconditions = []
    


# Contracts for weaver.registry.generate
class WeaverRegistryGenerateContracts:
    """Contract definitions for weaver.registry.generate"""
    
    
    @staticmethod
    def require_registry_generate_registry_path(registry_generate_registry_path: str) -> bool:
        """Path to the semantic convention registry - Required"""
        return isinstance(registry_generate_registry_path, str) and len(registry_generate_registry_path) > 0
    
    @staticmethod
    def require_registry_generate_target(registry_generate_target: str) -> bool:
        """Target language or format for generation - Required"""
        return isinstance(registry_generate_target, str) and len(registry_generate_target) > 0
    
    
    @staticmethod
    def require_registry_generate_output_dir(registry_generate_output_dir: str) -> bool:
        """Output directory for generated files - Required"""
        return isinstance(registry_generate_output_dir, str) and len(registry_generate_output_dir) > 0
    
    
    @staticmethod
    def require_registry_generate_files_count(registry_generate_files_count: int) -> bool:
        """Number of files generated - Required"""
        return isinstance(registry_generate_files_count, int) and registry_generate_files_count >= 0
    
    
    
    
    # Default contracts
    preconditions = []
    postconditions = []
    


# Contracts for weaver.registry.resolve
class WeaverRegistryResolveContracts:
    """Contract definitions for weaver.registry.resolve"""
    
    
    @staticmethod
    def require_registry_resolve_registry_path(registry_resolve_registry_path: str) -> bool:
        """Path to the registry to resolve - Required"""
        return isinstance(registry_resolve_registry_path, str) and len(registry_resolve_registry_path) > 0
    
    
    
    @staticmethod
    def require_registry_resolve_groups_count(registry_resolve_groups_count: int) -> bool:
        """Number of groups in resolved registry - Required"""
        return isinstance(registry_resolve_groups_count, int) and registry_resolve_groups_count >= 0
    
    
    
    # Default contracts
    preconditions = []
    postconditions = []
    


# Contracts for weaver.registry.stats
class WeaverRegistryStatsContracts:
    """Contract definitions for weaver.registry.stats"""
    
    
    @staticmethod
    def require_registry_stats_registry_path(registry_stats_registry_path: str) -> bool:
        """Path to the registry - Required"""
        return isinstance(registry_stats_registry_path, str) and len(registry_stats_registry_path) > 0
    
    @staticmethod
    def require_registry_stats_total_groups(registry_stats_total_groups: int) -> bool:
        """Total number of groups - Required"""
        return isinstance(registry_stats_total_groups, int) and registry_stats_total_groups >= 0
    
    @staticmethod
    def require_registry_stats_total_attributes(registry_stats_total_attributes: int) -> bool:
        """Total number of attributes - Required"""
        return isinstance(registry_stats_total_attributes, int) and registry_stats_total_attributes >= 0
    
    
    
    
    
    # Default contracts
    preconditions = []
    postconditions = []
    


# Contracts for weaver.multi.generate
class WeaverMultiGenerateContracts:
    """Contract definitions for weaver.multi.generate"""
    
    
    @staticmethod
    def require_multi_generate_registry_path(multi_generate_registry_path: str) -> bool:
        """Path to the registry - Required"""
        return isinstance(multi_generate_registry_path, str) and len(multi_generate_registry_path) > 0
    
    @staticmethod
    def require_multi_generate_languages(multi_generate_languages: List[str]) -> bool:
        """List of target languages - Required"""
        return isinstance(multi_generate_languages, list) and all(isinstance(i, str) for i in multi_generate_languages)
    
    
    @staticmethod
    def require_multi_generate_total_files(multi_generate_total_files: int) -> bool:
        """Total files generated across all languages - Required"""
        return isinstance(multi_generate_total_files, int) and multi_generate_total_files >= 0
    
    
    
    
    # Default contracts
    preconditions = []
    postconditions = []
    



# Apply contracts to operations
def apply_contracts(func, contract_class):
    """Apply all contracts from a contract class to a function"""
    if hasattr(contract_class, 'preconditions'):
        for pre in contract_class.preconditions:
            func = pre(func)
    
    if hasattr(contract_class, 'postconditions'):
        for post in contract_class.postconditions:
            func = post(func)
    
    return func