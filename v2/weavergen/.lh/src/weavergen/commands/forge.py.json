{
    "sourceFile": "src/weavergen/commands/forge.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1751480266657,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751480749056,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,13 @@\n-\"\"\"Weaver Forge lifecycle commands for WeaverGen v2 - Real Weaver integration.\"\"\"\n+\"\"\"Weaver Forge code generation commands for WeaverGen v2 - Real Weaver integration.\"\"\"\n \n from pathlib import Path\n from typing import Optional, List\n import typer\n from rich.console import Console\n from rich.table import Table\n from rich.progress import Progress, SpinnerColumn, TextColumn\n import yaml\n-import subprocess\n import json\n from opentelemetry import trace\n from opentelemetry.trace import Status, StatusCode\n from pydantic import BaseModel, Field\n@@ -24,9 +23,9 @@\n from weavergen.engine.service_task import WeaverGenServiceEnvironment\n from weavergen.engine.forge_service_tasks import register_forge_tasks\n \n # Initialize CLI app and console\n-forge_app = typer.Typer(help=\"Weaver Forge lifecycle commands - Real Weaver integration\")\n+forge_app = typer.Typer(help=\"Weaver Forge code generation commands - Real Weaver integration\")\n console = Console()\n tracer = trace.get_tracer(__name__)\n \n # Initialize Weaver integration\n@@ -84,150 +83,9 @@\n     output_dir: Path = Field(default=Path(\"generated\"))\n     strict_validation: bool = True\n \n \n-class SemanticValidationResult(BaseModel):\n-    \"\"\"Result of semantic convention validation.\"\"\"\n-    valid: bool\n-    errors: List[str] = Field(default_factory=list)\n-    warnings: List[str] = Field(default_factory=list)\n-    registry_path: Path\n-\n-\n @forge_app.command()\n-def init(\n-    name: str = typer.Argument(..., help=\"Name of your semantic convention registry\"),\n-    output_dir: Path = typer.Option(Path(\"./semantic_conventions\"), help=\"Output directory for semantic conventions\"),\n-    with_examples: bool = typer.Option(True, help=\"Include example semantic convention files\")\n-):\n-    \"\"\"Initialize a new semantic convention registry with starter YAML files (Real Weaver integration).\"\"\"\n-    with tracer.start_as_current_span(\"forge.init.real\") as span:\n-        span.set_attribute(\"registry_name\", name)\n-        span.set_attribute(\"output_dir\", str(output_dir))\n-        \n-        try:\n-            # Get Weaver integration\n-            weaver = get_weaver_integration()\n-            span.set_attribute(\"weaver.version\", weaver.get_weaver_version())\n-            \n-            # Create output directory\n-            output_dir.mkdir(parents=True, exist_ok=True)\n-            \n-            # Create registry manifest\n-            manifest_file = output_dir / \"registry_manifest.yaml\"\n-            manifest_content = f\"\"\"# WeaverGen Registry Manifest\n-registry:\n-  name: {name}\n-  version: \"1.0.0\"\n-  description: \"Semantic convention registry for {name}\"\n-  maintainers:\n-    - name: \"WeaverGen\"\n-      email: \"weavergen@example.com\"\n-  \n-  # Registry configuration\n-  config:\n-    future_validation: true\n-    strict_mode: false\n-    \n-  # Dependencies\n-  dependencies:\n-    - url: \"https://github.com/open-telemetry/semantic-conventions.git[model]\"\n-      version: \"main\"\n-      \n-  # Local semantic conventions\n-  conventions:\n-    - path: \"./model\"\n-      description: \"Local semantic conventions\"\n-\"\"\"\n-            \n-            manifest_file.write_text(manifest_content)\n-            console.print(f\"[green]‚úì[/green] Created registry manifest: {manifest_file}\")\n-            \n-            # Create model directory\n-            model_dir = output_dir / \"model\"\n-            model_dir.mkdir(exist_ok=True)\n-            \n-            # Create example semantic conventions if requested\n-            if with_examples:\n-                example_file = model_dir / f\"{name}_common.yaml\"\n-                example_content = f\"\"\"# {name} Common Semantic Conventions\n-groups:\n-  - id: {name}.service\n-    prefix: service\n-    type: attribute_group\n-    brief: 'Common service attributes for {name}'\n-    attributes:\n-      - id: name\n-        type: string\n-        requirement_level: required\n-        brief: 'Service name'\n-        examples: ['{name}-api', '{name}-worker']\n-      - id: version\n-        type: string\n-        requirement_level: recommended\n-        brief: 'Service version'\n-        examples: ['1.0.0', '2.1.3']\n-      - id: instance.id\n-        type: string\n-        requirement_level: recommended\n-        brief: 'Service instance identifier'\n-        examples: ['instance-1', 'pod-abc123']\n-\n-  - id: {name}.operation\n-    prefix: operation\n-    type: span\n-    brief: 'Common operation attributes for {name}'\n-    attributes:\n-      - ref: {name}.service.name\n-      - id: duration_ms\n-        type: int\n-        requirement_level: recommended\n-        brief: 'Operation duration in milliseconds'\n-      - id: status\n-        type: string\n-        requirement_level: required\n-        brief: 'Operation status'\n-        examples: ['success', 'failure', 'timeout']\n-\"\"\"\n-                \n-                example_file.write_text(example_content)\n-                console.print(f\"[green]‚úì[/green] Created example conventions: {example_file}\")\n-            \n-            # Validate the registry using Weaver\n-            console.print(f\"\\n[blue]Validating registry with Weaver...[/blue]\")\n-            validation_result = weaver.check_registry(output_dir, strict=False)\n-            \n-            if validation_result.valid:\n-                console.print(\"[green]‚úì[/green] Registry validation passed!\")\n-                \n-                # Get registry statistics\n-                stats = weaver.get_registry_stats(output_dir)\n-                if stats.valid:\n-                    console.print(f\"\\n[blue]Registry Statistics:[/blue]\")\n-                    console.print(f\"  ‚Ä¢ Groups: {stats.groups_count}\")\n-                    console.print(f\"  ‚Ä¢ Attributes: {stats.attributes_count}\")\n-                    console.print(f\"  ‚Ä¢ Metrics: {stats.metrics_count}\")\n-                    console.print(f\"  ‚Ä¢ Spans: {stats.spans_count}\")\n-                    console.print(f\"  ‚Ä¢ Resources: {stats.resources_count}\")\n-            else:\n-                console.print(\"[yellow]‚ö†[/yellow] Registry validation warnings:\")\n-                for warning in validation_result.warnings:\n-                    console.print(f\"  ‚Ä¢ {warning}\")\n-            \n-            console.print(f\"\\n[green]‚úì[/green] Registry '{name}' initialized successfully!\")\n-            console.print(f\"üìÅ Registry location: {output_dir.absolute()}\")\n-            console.print(f\"üîß Weaver version: {weaver.get_weaver_version()}\")\n-            \n-            span.set_status(Status(StatusCode.OK))\n-            \n-        except Exception as e:\n-            span.record_exception(e)\n-            span.set_status(Status(StatusCode.ERROR, str(e)))\n-            console.print(f\"[red]FATAL: Registry initialization failed: {e}[/red]\")\n-            raise typer.Exit(1)\n-\n-\n-@forge_app.command()\n def generate(\n     registry_url: str = typer.Argument(..., help=\"URL or path to semantic convention registry\"),\n     output_dir: Path = typer.Option(Path(\"./generated\"), help=\"Output directory for generated code\"),\n     language: str = typer.Option(\"python\", help=\"Target programming language\"),\n@@ -327,67 +185,8 @@\n             raise typer.Exit(1)\n \n \n @forge_app.command()\n-def validate(\n-    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n-    strict: bool = typer.Option(False, help=\"Enable strict validation mode\")\n-):\n-    \"\"\"Validate semantic conventions YAML files using real Weaver.\"\"\"\n-    with tracer.start_as_current_span(\"forge.validate.real\") as span:\n-        span.set_attribute(\"registry\", str(registry_path))\n-        span.set_attribute(\"strict\", strict)\n-        \n-        try:\n-            # Get Weaver integration\n-            weaver = get_weaver_integration()\n-            \n-            # Validate using real Weaver\n-            result = weaver.check_registry(registry_path, strict=strict)\n-            \n-            # Display results\n-            if result.valid:\n-                console.print(\"[green]‚úì[/green] Semantic conventions are valid!\")\n-                \n-                # Show warnings if any\n-                if result.warnings:\n-                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n-                    for warning in result.warnings:\n-                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n-                \n-                # Get and display registry statistics\n-                stats = weaver.get_registry_stats(registry_path)\n-                if stats.valid:\n-                    console.print(f\"\\n[blue]Registry Statistics:[/blue]\")\n-                    console.print(f\"  ‚Ä¢ Groups: {stats.groups_count}\")\n-                    console.print(f\"  ‚Ä¢ Attributes: {stats.attributes_count}\")\n-                    console.print(f\"  ‚Ä¢ Metrics: {stats.metrics_count}\")\n-                    console.print(f\"  ‚Ä¢ Spans: {stats.spans_count}\")\n-                    console.print(f\"  ‚Ä¢ Resources: {stats.resources_count}\")\n-                \n-                span.set_status(Status(StatusCode.OK))\n-            else:\n-                console.print(\"[red]‚úó[/red] Validation errors found:\")\n-                for error in result.errors:\n-                    console.print(f\"  [red]‚Ä¢[/red] {error}\")\n-                \n-                # Show warnings too\n-                if result.warnings:\n-                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n-                    for warning in result.warnings:\n-                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n-                \n-                span.set_status(Status(StatusCode.ERROR, f\"Validation failed: {len(result.errors)} errors\"))\n-                raise typer.Exit(1)\n-                \n-        except Exception as e:\n-            span.record_exception(e)\n-            span.set_status(Status(StatusCode.ERROR, str(e)))\n-            console.print(f\"[red]Error: {e}[/red]\")\n-            raise typer.Exit(1)\n-\n-\n-@forge_app.command()\n def templates(\n     list_all: bool = typer.Option(True, \"--list\", \"-l\", help=\"List all available templates\"),\n     language: Optional[str] = typer.Option(None, help=\"Filter templates by language\")\n ):\n@@ -437,47 +236,57 @@\n             raise typer.Exit(1)\n \n \n @forge_app.command()\n-def stats(\n-    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\")\n+def validate(\n+    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n+    strict: bool = typer.Option(False, help=\"Enable strict validation mode\")\n ):\n-    \"\"\"Get detailed statistics about a semantic convention registry using real Weaver.\"\"\"\n-    with tracer.start_as_current_span(\"forge.stats.real\") as span:\n+    \"\"\"Validate semantic conventions YAML files using real Weaver.\"\"\"\n+    with tracer.start_as_current_span(\"forge.validate.real\") as span:\n         span.set_attribute(\"registry\", str(registry_path))\n+        span.set_attribute(\"strict\", strict)\n         \n         try:\n             # Get Weaver integration\n             weaver = get_weaver_integration()\n             \n-            # Get registry statistics\n-            stats = weaver.get_registry_stats(registry_path)\n+            # Validate using real Weaver\n+            result = weaver.check_registry(registry_path, strict=strict)\n             \n-            if stats.valid:\n-                console.print(f\"[blue]Registry Statistics for {registry_path.name}:[/blue]\\n\")\n+            # Display results\n+            if result.valid:\n+                console.print(\"[green]‚úì[/green] Semantic conventions are valid!\")\n                 \n-                # Display basic stats\n-                console.print(f\"üìä Groups: {stats.groups_count}\")\n-                console.print(f\"üè∑Ô∏è  Attributes: {stats.attributes_count}\")\n-                console.print(f\"üìà Metrics: {stats.metrics_count}\")\n-                console.print(f\"üîó Spans: {stats.spans_count}\")\n-                console.print(f\"üì¶ Resources: {stats.resources_count}\")\n+                # Show warnings if any\n+                if result.warnings:\n+                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n+                    for warning in result.warnings:\n+                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n                 \n-                # Display detailed stats if available\n-                if stats.stats:\n-                    console.print(f\"\\n[blue]Detailed Statistics:[/blue]\")\n-                    for key, value in stats.stats.items():\n-                        if isinstance(value, (int, float)):\n-                            console.print(f\"  ‚Ä¢ {key}: {value}\")\n-                        elif isinstance(value, dict):\n-                            console.print(f\"  ‚Ä¢ {key}:\")\n-                            for sub_key, sub_value in value.items():\n-                                console.print(f\"    - {sub_key}: {sub_value}\")\n+                # Get and display registry statistics\n+                stats = weaver.get_registry_stats(registry_path)\n+                if stats.valid:\n+                    console.print(f\"\\n[blue]Registry Statistics:[/blue]\")\n+                    console.print(f\"  ‚Ä¢ Groups: {stats.groups_count}\")\n+                    console.print(f\"  ‚Ä¢ Attributes: {stats.attributes_count}\")\n+                    console.print(f\"  ‚Ä¢ Metrics: {stats.metrics_count}\")\n+                    console.print(f\"  ‚Ä¢ Spans: {stats.spans_count}\")\n+                    console.print(f\"  ‚Ä¢ Resources: {stats.resources_count}\")\n                 \n                 span.set_status(Status(StatusCode.OK))\n             else:\n-                console.print(\"[red]Failed to get registry statistics[/red]\")\n-                span.set_status(Status(StatusCode.ERROR, \"Stats failed\"))\n+                console.print(\"[red]‚úó[/red] Validation errors found:\")\n+                for error in result.errors:\n+                    console.print(f\"  [red]‚Ä¢[/red] {error}\")\n+                \n+                # Show warnings too\n+                if result.warnings:\n+                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n+                    for warning in result.warnings:\n+                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n+                \n+                span.set_status(Status(StatusCode.ERROR, f\"Validation failed: {len(result.errors)} errors\"))\n                 raise typer.Exit(1)\n                 \n         except Exception as e:\n             span.record_exception(e)\n@@ -485,41 +294,8 @@\n             console.print(f\"[red]Error: {e}[/red]\")\n             raise typer.Exit(1)\n \n \n-@forge_app.command()\n-def resolve(\n-    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n-    output_file: Optional[Path] = typer.Option(None, help=\"Output file for resolved registry\")\n-):\n-    \"\"\"Resolve a semantic convention registry to a single file using real Weaver.\"\"\"\n-    with tracer.start_as_current_span(\"forge.resolve.real\") as span:\n-        span.set_attribute(\"registry\", str(registry_path))\n-        \n-        try:\n-            # Get Weaver integration\n-            weaver = get_weaver_integration()\n-            \n-            # Resolve registry\n-            resolved_file = weaver.resolve_registry(registry_path, output_file)\n-            \n-            console.print(f\"[green]‚úì[/green] Registry resolved successfully!\")\n-            console.print(f\"üìÅ Resolved file: {resolved_file}\")\n-            \n-            # Show file size\n-            if resolved_file.exists():\n-                size = resolved_file.stat().st_size\n-                console.print(f\"üìè File size: {size:,} bytes\")\n-            \n-            span.set_status(Status(StatusCode.OK))\n-            \n-        except Exception as e:\n-            span.record_exception(e)\n-            span.set_status(Status(StatusCode.ERROR, str(e)))\n-            console.print(f\"[red]Error: {e}[/red]\")\n-            raise typer.Exit(1)\n-\n-\n # Legacy commands for backward compatibility\n @forge_app.command(\"forge-generate\")\n def forge_generate(\n     semantic_file: Path = typer.Argument(..., help=\"Path to semantic conventions YAML\"),\n"
                }
            ],
            "date": 1751480266657,
            "name": "Commit-0",
            "content": "\"\"\"Weaver Forge lifecycle commands for WeaverGen v2 - Real Weaver integration.\"\"\"\n\nfrom pathlib import Path\nfrom typing import Optional, List\nimport typer\nfrom rich.console import Console\nfrom rich.table import Table\nfrom rich.progress import Progress, SpinnerColumn, TextColumn\nimport yaml\nimport subprocess\nimport json\nfrom opentelemetry import trace\nfrom opentelemetry.trace import Status, StatusCode\nfrom pydantic import BaseModel, Field\n\n# Import real Weaver integration\nfrom ..weaver_integration import (\n    WeaverIntegration, WeaverConfig, WeaverTarget,\n    WeaverValidationResult, WeaverGenerationResult, WeaverRegistryInfo\n)\n\n# Import BPMN engine components\nfrom weavergen.engine.simple_engine import SimpleBpmnEngine\nfrom weavergen.engine.service_task import WeaverGenServiceEnvironment\nfrom weavergen.engine.forge_service_tasks import register_forge_tasks\n\n# Initialize CLI app and console\nforge_app = typer.Typer(help=\"Weaver Forge lifecycle commands - Real Weaver integration\")\nconsole = Console()\ntracer = trace.get_tracer(__name__)\n\n# Initialize Weaver integration\n_weaver_integration = None\n\ndef get_weaver_integration():\n    \"\"\"Get or create Weaver integration instance.\"\"\"\n    global _weaver_integration\n    if _weaver_integration is None:\n        config = WeaverConfig(\n            weaver_path=Path(\"weaver\"),\n            templates_dir=Path(\"templates\"),\n            output_dir=Path(\"generated\"),\n            future_validation=True\n        )\n        _weaver_integration = WeaverIntegration(config)\n    return _weaver_integration\n\n# Initialize BPMN engine\n_engine = None\n_environment = None\n\ndef get_bpmn_engine():\n    \"\"\"Get or create BPMN engine with forge tasks registered.\"\"\"\n    global _engine, _environment\n    if _engine is None:\n        _environment = WeaverGenServiceEnvironment()\n        register_forge_tasks(_environment)\n        _engine = SimpleBpmnEngine(_environment)\n        \n        # Load forge workflows - fix path to go up one more level\n        workflow_dir = Path(__file__).parent.parent.parent / \"workflows\" / \"bpmn\" / \"forge\"\n        if workflow_dir.exists():\n            for bpmn_file in workflow_dir.glob(\"*.bpmn\"):\n                try:\n                    # Add spec with the actual process ID from the file\n                    # We need to load and parse to find the process ID\n                    _engine.parser.add_bpmn_file(str(bpmn_file))\n                    # Get all process IDs from the parsed file\n                    for process_id in _engine.parser.get_process_ids():\n                        # Register each process\n                        spec = _engine.parser.get_spec(process_id)\n                        _engine.specs[process_id] = spec\n                        console.print(f\"[green]‚úì[/green] Loaded BPMN process: {process_id}\")\n                except Exception as e:\n                    console.print(f\"[red]ERROR: Could not load {bpmn_file}: {e}[/red]\")\n    \n    return _engine, _environment\n\n\nclass ForgeConfig(BaseModel):\n    \"\"\"Configuration for Weaver Forge operations.\"\"\"\n    weaver_path: Path = Field(default=Path(\"weaver\"))\n    default_language: str = \"python\"\n    output_dir: Path = Field(default=Path(\"generated\"))\n    strict_validation: bool = True\n\n\nclass SemanticValidationResult(BaseModel):\n    \"\"\"Result of semantic convention validation.\"\"\"\n    valid: bool\n    errors: List[str] = Field(default_factory=list)\n    warnings: List[str] = Field(default_factory=list)\n    registry_path: Path\n\n\n@forge_app.command()\ndef init(\n    name: str = typer.Argument(..., help=\"Name of your semantic convention registry\"),\n    output_dir: Path = typer.Option(Path(\"./semantic_conventions\"), help=\"Output directory for semantic conventions\"),\n    with_examples: bool = typer.Option(True, help=\"Include example semantic convention files\")\n):\n    \"\"\"Initialize a new semantic convention registry with starter YAML files (Real Weaver integration).\"\"\"\n    with tracer.start_as_current_span(\"forge.init.real\") as span:\n        span.set_attribute(\"registry_name\", name)\n        span.set_attribute(\"output_dir\", str(output_dir))\n        \n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            span.set_attribute(\"weaver.version\", weaver.get_weaver_version())\n            \n            # Create output directory\n            output_dir.mkdir(parents=True, exist_ok=True)\n            \n            # Create registry manifest\n            manifest_file = output_dir / \"registry_manifest.yaml\"\n            manifest_content = f\"\"\"# WeaverGen Registry Manifest\nregistry:\n  name: {name}\n  version: \"1.0.0\"\n  description: \"Semantic convention registry for {name}\"\n  maintainers:\n    - name: \"WeaverGen\"\n      email: \"weavergen@example.com\"\n  \n  # Registry configuration\n  config:\n    future_validation: true\n    strict_mode: false\n    \n  # Dependencies\n  dependencies:\n    - url: \"https://github.com/open-telemetry/semantic-conventions.git[model]\"\n      version: \"main\"\n      \n  # Local semantic conventions\n  conventions:\n    - path: \"./model\"\n      description: \"Local semantic conventions\"\n\"\"\"\n            \n            manifest_file.write_text(manifest_content)\n            console.print(f\"[green]‚úì[/green] Created registry manifest: {manifest_file}\")\n            \n            # Create model directory\n            model_dir = output_dir / \"model\"\n            model_dir.mkdir(exist_ok=True)\n            \n            # Create example semantic conventions if requested\n            if with_examples:\n                example_file = model_dir / f\"{name}_common.yaml\"\n                example_content = f\"\"\"# {name} Common Semantic Conventions\ngroups:\n  - id: {name}.service\n    prefix: service\n    type: attribute_group\n    brief: 'Common service attributes for {name}'\n    attributes:\n      - id: name\n        type: string\n        requirement_level: required\n        brief: 'Service name'\n        examples: ['{name}-api', '{name}-worker']\n      - id: version\n        type: string\n        requirement_level: recommended\n        brief: 'Service version'\n        examples: ['1.0.0', '2.1.3']\n      - id: instance.id\n        type: string\n        requirement_level: recommended\n        brief: 'Service instance identifier'\n        examples: ['instance-1', 'pod-abc123']\n\n  - id: {name}.operation\n    prefix: operation\n    type: span\n    brief: 'Common operation attributes for {name}'\n    attributes:\n      - ref: {name}.service.name\n      - id: duration_ms\n        type: int\n        requirement_level: recommended\n        brief: 'Operation duration in milliseconds'\n      - id: status\n        type: string\n        requirement_level: required\n        brief: 'Operation status'\n        examples: ['success', 'failure', 'timeout']\n\"\"\"\n                \n                example_file.write_text(example_content)\n                console.print(f\"[green]‚úì[/green] Created example conventions: {example_file}\")\n            \n            # Validate the registry using Weaver\n            console.print(f\"\\n[blue]Validating registry with Weaver...[/blue]\")\n            validation_result = weaver.check_registry(output_dir, strict=False)\n            \n            if validation_result.valid:\n                console.print(\"[green]‚úì[/green] Registry validation passed!\")\n                \n                # Get registry statistics\n                stats = weaver.get_registry_stats(output_dir)\n                if stats.valid:\n                    console.print(f\"\\n[blue]Registry Statistics:[/blue]\")\n                    console.print(f\"  ‚Ä¢ Groups: {stats.groups_count}\")\n                    console.print(f\"  ‚Ä¢ Attributes: {stats.attributes_count}\")\n                    console.print(f\"  ‚Ä¢ Metrics: {stats.metrics_count}\")\n                    console.print(f\"  ‚Ä¢ Spans: {stats.spans_count}\")\n                    console.print(f\"  ‚Ä¢ Resources: {stats.resources_count}\")\n            else:\n                console.print(\"[yellow]‚ö†[/yellow] Registry validation warnings:\")\n                for warning in validation_result.warnings:\n                    console.print(f\"  ‚Ä¢ {warning}\")\n            \n            console.print(f\"\\n[green]‚úì[/green] Registry '{name}' initialized successfully!\")\n            console.print(f\"üìÅ Registry location: {output_dir.absolute()}\")\n            console.print(f\"üîß Weaver version: {weaver.get_weaver_version()}\")\n            \n            span.set_status(Status(StatusCode.OK))\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]FATAL: Registry initialization failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@forge_app.command()\ndef generate(\n    registry_url: str = typer.Argument(..., help=\"URL or path to semantic convention registry\"),\n    output_dir: Path = typer.Option(Path(\"./generated\"), help=\"Output directory for generated code\"),\n    language: str = typer.Option(\"python\", help=\"Target programming language\"),\n    template: Optional[str] = typer.Option(None, help=\"Custom template to use\"),\n    verbose: bool = typer.Option(False, help=\"Enable verbose output\")\n):\n    \"\"\"Generate code from semantic conventions using real Weaver Forge (80/20 core command).\"\"\"\n    with tracer.start_as_current_span(\"forge.generate.real\") as span:\n        span.set_attribute(\"language\", language)\n        span.set_attribute(\"registry\", registry_url)\n        \n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            \n            # Map language to Weaver target\n            target_map = {\n                \"python\": WeaverTarget.CODE_GEN_PYTHON,\n                \"go\": WeaverTarget.CODE_GEN_GO,\n                \"rust\": WeaverTarget.CODE_GEN_RUST,\n                \"java\": WeaverTarget.CODE_GEN_JAVA,\n                \"typescript\": WeaverTarget.CODE_GEN_TYPESCRIPT,\n                \"dotnet\": WeaverTarget.CODE_GEN_DOTNET,\n            }\n            \n            target = target_map.get(language.lower())\n            if not target:\n                console.print(f\"[red]Unsupported language: {language}[/red]\")\n                console.print(f\"Supported languages: {', '.join(target_map.keys())}\")\n                raise typer.Exit(1)\n            \n            span.set_attribute(\"weaver.target\", target.value)\n            \n            with Progress(\n                SpinnerColumn(),\n                TextColumn(\"[progress.description]{task.description}\"),\n                console=console,\n            ) as progress:\n                # Validate semantic conventions first\n                progress.add_task(\"Validating semantic conventions...\", total=None)\n                validation_result = weaver.check_registry(registry_url, strict=False)\n                \n                if not validation_result.valid:\n                    console.print(\"[red]Validation failed![/red]\")\n                    for error in validation_result.errors:\n                        console.print(f\"  ‚Ä¢ {error}\")\n                    span.set_status(Status(StatusCode.ERROR, \"Validation failed\"))\n                    raise typer.Exit(1)\n                \n                # Execute generation via real Weaver\n                progress.add_task(f\"Generating {language} code with Weaver...\", total=None)\n                \n                # Prepare parameters\n                parameters = {}\n                if template:\n                    parameters[\"template\"] = template\n                \n                generation_result = weaver.generate_code(\n                    registry_path=registry_url,\n                    target=target,\n                    output_dir=output_dir,\n                    parameters=parameters\n                )\n                \n                if generation_result.success:\n                    console.print(f\"[green]‚úì[/green] Generated {language} code in {output_dir}\")\n                    \n                    # Show generated files\n                    if generation_result.generated_files:\n                        console.print(f\"\\n[blue]Generated files ({len(generation_result.generated_files)}):[/blue]\")\n                        for file in generation_result.generated_files[:10]:  # Show first 10\n                            console.print(f\"  ‚Ä¢ {file}\")\n                        if len(generation_result.generated_files) > 10:\n                            console.print(f\"  ‚Ä¢ ... and {len(generation_result.generated_files) - 10} more\")\n                    \n                    # Show diagnostics if any\n                    if generation_result.diagnostics:\n                        console.print(f\"\\n[yellow]Diagnostics ({len(generation_result.diagnostics)}):[/yellow]\")\n                        for diagnostic in generation_result.diagnostics[:5]:  # Show first 5\n                            if isinstance(diagnostic, dict):\n                                msg = diagnostic.get(\"message\", str(diagnostic))\n                                console.print(f\"  ‚Ä¢ {msg}\")\n                    \n                    span.set_status(Status(StatusCode.OK))\n                else:\n                    console.print(\"[red]Generation failed![/red]\")\n                    console.print(f\"Return code: {generation_result.return_code}\")\n                    if generation_result.stderr:\n                        console.print(f\"Error: {generation_result.stderr}\")\n                    span.set_status(Status(StatusCode.ERROR, f\"Generation failed: {generation_result.return_code}\"))\n                    raise typer.Exit(generation_result.return_code)\n                    \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@forge_app.command()\ndef validate(\n    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n    strict: bool = typer.Option(False, help=\"Enable strict validation mode\")\n):\n    \"\"\"Validate semantic conventions YAML files using real Weaver.\"\"\"\n    with tracer.start_as_current_span(\"forge.validate.real\") as span:\n        span.set_attribute(\"registry\", str(registry_path))\n        span.set_attribute(\"strict\", strict)\n        \n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            \n            # Validate using real Weaver\n            result = weaver.check_registry(registry_path, strict=strict)\n            \n            # Display results\n            if result.valid:\n                console.print(\"[green]‚úì[/green] Semantic conventions are valid!\")\n                \n                # Show warnings if any\n                if result.warnings:\n                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n                    for warning in result.warnings:\n                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n                \n                # Get and display registry statistics\n                stats = weaver.get_registry_stats(registry_path)\n                if stats.valid:\n                    console.print(f\"\\n[blue]Registry Statistics:[/blue]\")\n                    console.print(f\"  ‚Ä¢ Groups: {stats.groups_count}\")\n                    console.print(f\"  ‚Ä¢ Attributes: {stats.attributes_count}\")\n                    console.print(f\"  ‚Ä¢ Metrics: {stats.metrics_count}\")\n                    console.print(f\"  ‚Ä¢ Spans: {stats.spans_count}\")\n                    console.print(f\"  ‚Ä¢ Resources: {stats.resources_count}\")\n                \n                span.set_status(Status(StatusCode.OK))\n            else:\n                console.print(\"[red]‚úó[/red] Validation errors found:\")\n                for error in result.errors:\n                    console.print(f\"  [red]‚Ä¢[/red] {error}\")\n                \n                # Show warnings too\n                if result.warnings:\n                    console.print(\"\\n[yellow]Warnings:[/yellow]\")\n                    for warning in result.warnings:\n                        console.print(f\"  [yellow]‚Ä¢[/yellow] {warning}\")\n                \n                span.set_status(Status(StatusCode.ERROR, f\"Validation failed: {len(result.errors)} errors\"))\n                raise typer.Exit(1)\n                \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@forge_app.command()\ndef templates(\n    list_all: bool = typer.Option(True, \"--list\", \"-l\", help=\"List all available templates\"),\n    language: Optional[str] = typer.Option(None, help=\"Filter templates by language\")\n):\n    \"\"\"List and manage code generation templates using real Weaver.\"\"\"\n    with tracer.start_as_current_span(\"forge.templates.real\") as span:\n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            \n            # Get available targets\n            targets = weaver.get_available_targets()\n            \n            # Filter by language if specified\n            if language:\n                targets = [t for t in targets if language.lower() in t.value.lower()]\n            \n            # Display templates\n            console.print(f\"[blue]Available Weaver Templates ({len(targets)}):[/blue]\\n\")\n            \n            table = Table(title=\"Weaver Generation Targets\")\n            table.add_column(\"Target\", style=\"cyan\")\n            table.add_column(\"Language\", style=\"green\")\n            table.add_column(\"Description\", style=\"white\")\n            \n            for target in targets:\n                # Extract language from target name\n                lang = target.value.replace(\"codegen_\", \"\").title()\n                if lang == \"Json_schema\":\n                    lang = \"JSON Schema\"\n                elif lang == \"Gh_workflow_command\":\n                    lang = \"GitHub Workflow\"\n                \n                table.add_row(target.value, lang, f\"Generate {lang} code from semantic conventions\")\n            \n            console.print(table)\n            \n            # Show Weaver version\n            version = weaver.get_weaver_version()\n            console.print(f\"\\n[dim]Weaver version: {version}[/dim]\")\n            \n            span.set_status(Status(StatusCode.OK))\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@forge_app.command()\ndef stats(\n    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\")\n):\n    \"\"\"Get detailed statistics about a semantic convention registry using real Weaver.\"\"\"\n    with tracer.start_as_current_span(\"forge.stats.real\") as span:\n        span.set_attribute(\"registry\", str(registry_path))\n        \n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            \n            # Get registry statistics\n            stats = weaver.get_registry_stats(registry_path)\n            \n            if stats.valid:\n                console.print(f\"[blue]Registry Statistics for {registry_path.name}:[/blue]\\n\")\n                \n                # Display basic stats\n                console.print(f\"üìä Groups: {stats.groups_count}\")\n                console.print(f\"üè∑Ô∏è  Attributes: {stats.attributes_count}\")\n                console.print(f\"üìà Metrics: {stats.metrics_count}\")\n                console.print(f\"üîó Spans: {stats.spans_count}\")\n                console.print(f\"üì¶ Resources: {stats.resources_count}\")\n                \n                # Display detailed stats if available\n                if stats.stats:\n                    console.print(f\"\\n[blue]Detailed Statistics:[/blue]\")\n                    for key, value in stats.stats.items():\n                        if isinstance(value, (int, float)):\n                            console.print(f\"  ‚Ä¢ {key}: {value}\")\n                        elif isinstance(value, dict):\n                            console.print(f\"  ‚Ä¢ {key}:\")\n                            for sub_key, sub_value in value.items():\n                                console.print(f\"    - {sub_key}: {sub_value}\")\n                \n                span.set_status(Status(StatusCode.OK))\n            else:\n                console.print(\"[red]Failed to get registry statistics[/red]\")\n                span.set_status(Status(StatusCode.ERROR, \"Stats failed\"))\n                raise typer.Exit(1)\n                \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@forge_app.command()\ndef resolve(\n    registry_path: Path = typer.Argument(..., help=\"Path to semantic convention registry\"),\n    output_file: Optional[Path] = typer.Option(None, help=\"Output file for resolved registry\")\n):\n    \"\"\"Resolve a semantic convention registry to a single file using real Weaver.\"\"\"\n    with tracer.start_as_current_span(\"forge.resolve.real\") as span:\n        span.set_attribute(\"registry\", str(registry_path))\n        \n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            \n            # Resolve registry\n            resolved_file = weaver.resolve_registry(registry_path, output_file)\n            \n            console.print(f\"[green]‚úì[/green] Registry resolved successfully!\")\n            console.print(f\"üìÅ Resolved file: {resolved_file}\")\n            \n            # Show file size\n            if resolved_file.exists():\n                size = resolved_file.stat().st_size\n                console.print(f\"üìè File size: {size:,} bytes\")\n            \n            span.set_status(Status(StatusCode.OK))\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n# Legacy commands for backward compatibility\n@forge_app.command(\"forge-generate\")\ndef forge_generate(\n    semantic_file: Path = typer.Argument(..., help=\"Path to semantic conventions YAML\"),\n    output_dir: Path = typer.Option(Path(\"generated_forge\"), help=\"Output directory\"),\n    components: Optional[List[str]] = typer.Option(None, help=\"Specific components to generate\"),\n    verbose: bool = typer.Option(False, help=\"Enable verbose output\")\n):\n    \"\"\"‚öíÔ∏è Advanced Forge generation - complete system from semantics (Real Weaver).\"\"\"\n    with tracer.start_as_current_span(\"forge.forge_generate.real\") as span:\n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            \n            console.print(f\"[blue]Generating complete system from {semantic_file}[/blue]\")\n            \n            # Generate Python code as default\n            generation_result = weaver.generate_code(\n                registry_path=semantic_file,\n                target=WeaverTarget.CODE_GEN_PYTHON,\n                output_dir=output_dir\n            )\n            \n            if generation_result.success:\n                console.print(f\"[green]‚úì[/green] Complete system generated in {output_dir}\")\n                console.print(f\"üìÅ Generated files: {len(generation_result.generated_files)}\")\n                \n                span.set_status(Status(StatusCode.OK))\n            else:\n                console.print(\"[red]Generation failed![/red]\")\n                span.set_status(Status(StatusCode.ERROR, f\"Generation failed: {generation_result.return_code}\"))\n                raise typer.Exit(1)\n                \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Error: {e}[/red]\")\n            raise typer.Exit(1)\n\n\n@forge_app.command(\"full-pipeline\")\ndef full_pipeline(\n    semantic_yaml: Path = typer.Argument(..., help=\"Path to semantic conventions YAML\"),\n    agents: int = typer.Option(5, help=\"Number of agents to generate\"),\n    output_dir: Path = typer.Option(Path(\"generated\"), help=\"Output directory\")\n):\n    \"\"\"Execute full pipeline: Semantics ‚Üí Forge ‚Üí Agents ‚Üí Validation (Real Weaver).\"\"\"\n    with tracer.start_as_current_span(\"forge.full_pipeline.real\") as span:\n        try:\n            # Get Weaver integration\n            weaver = get_weaver_integration()\n            \n            console.print(f\"[blue]Executing full pipeline with real Weaver integration[/blue]\")\n            \n            # Step 1: Validate semantics\n            console.print(f\"\\n[1/4] Validating semantic conventions...\")\n            validation_result = weaver.check_registry(semantic_yaml, strict=False)\n            \n            if not validation_result.valid:\n                console.print(\"[red]Validation failed![/red]\")\n                for error in validation_result.errors:\n                    console.print(f\"  ‚Ä¢ {error}\")\n                span.set_status(Status(StatusCode.ERROR, \"Validation failed\"))\n                raise typer.Exit(1)\n            \n            # Step 2: Generate code with Weaver\n            console.print(f\"\\n[2/4] Generating code with Weaver...\")\n            generation_result = weaver.generate_code(\n                registry_path=semantic_yaml,\n                target=WeaverTarget.CODE_GEN_PYTHON,\n                output_dir=output_dir / \"weaver\"\n            )\n            \n            if not generation_result.success:\n                console.print(\"[red]Weaver generation failed![/red]\")\n                span.set_status(Status(StatusCode.ERROR, \"Weaver generation failed\"))\n                raise typer.Exit(1)\n            \n            # Step 3: Generate agent system (placeholder for now)\n            console.print(f\"\\n[3/4] Generating {agents} agent system...\")\n            # TODO: Implement real agent generation\n            \n            # Step 4: Validate with spans\n            console.print(\"\\n[4/4] Validating system with OpenTelemetry spans...\")\n            # TODO: Implement real span validation\n            \n            console.print(\"\\n[green]‚úì[/green] Full pipeline completed successfully!\")\n            span.set_status(Status(StatusCode.OK))\n            \n        except Exception as e:\n            span.record_exception(e)\n            span.set_status(Status(StatusCode.ERROR, str(e)))\n            console.print(f\"[red]Pipeline failed: {e}[/red]\")\n            raise typer.Exit(1)\n\n\nif __name__ == \"__main__\":\n    forge_app()"
        }
    ]
}