# Generated by Weaver Forge - Operations Layer for Robert's Rules
# AI-EDITABLE: This layer contains business logic for parliamentary procedures

import os
from typing import Optional, List, Dict, Any
from pathlib import Path

# Import contracts and runtime
from contracts.roberts import *
from runtime.roberts import *

# Import the result type
from commands.roberts import ForgeResult

def roberts_meeting_start_execute(
    meeting_id: str,
    meeting_type: str,
    quorum: int,
    members_present: int,
    chair: str,
    secretary: str,
    agenda_items: Optional[Dict[str, str]] = None,
    minutes_path: Optional[str] = None,
) -> ForgeResult:
    """Start a new meeting according to Robert's Rules"""
    try:
        # Validate quorum
        if not validate_quorum(members_present, quorum):
            return ForgeResult(
                success=False,
                errors=[f"Quorum not met. Required: {quorum}, Present: {members_present}"]
            )
        
        # Start the meeting
        success = meeting_state.start_meeting(
            meeting_id=meeting_id,
            meeting_type=meeting_type,
            quorum=quorum,
            members_present=members_present,
            chair=chair,
            secretary=secretary,
            agenda_items=agenda_items
        )
        
        if not success:
            return ForgeResult(
                success=False,
                errors=[f"Meeting {meeting_id} already exists"]
            )
        
        return ForgeResult(
            success=True,
            data={
                "meeting_id": meeting_id,
                "status": "in_session",
                "quorum_met": True
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_motion_make_execute(
    motion_id: str,
    motion_type: str,
    motion_text: str,
    mover: str,
    requires_second: bool,
    debatable: bool,
    vote_required: str,
    motion_status: str,
    seconder: Optional[str] = None,
) -> ForgeResult:
    """Make a motion according to Robert's Rules"""
    try:
        # Validate motion type
        if not validate_motion_type(motion_type):
            return ForgeResult(
                success=False,
                errors=[f"Invalid motion type: {motion_type}"]
            )
        
        # Add the motion
        success = meeting_state.add_motion(
            motion_id=motion_id,
            motion_type=motion_type,
            text=motion_text,
            mover=mover,
            requires_second=requires_second,
            debatable=debatable,
            vote_required=vote_required
        )
        
        if not success:
            return ForgeResult(
                success=False,
                errors=[f"Motion {motion_id} already exists"]
            )
        
        # Handle immediate second if provided
        if seconder and requires_second:
            meeting_state.second_motion(motion_id, seconder)
            motion_status = "seconded"
        else:
            motion_status = "pending"
        
        return ForgeResult(
            success=True,
            data={
                "motion_id": motion_id,
                "status": motion_status,
                "requires_second": requires_second,
                "next_step": "second" if requires_second and not seconder else "debate" if debatable else "vote"
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_motion_second_execute(
    motion_id: str,
    motion_type: str,
    motion_text: str,
    mover: str,
    seconder: str,
    requires_second: bool,
    debatable: bool,
    vote_required: str,
    motion_status: str,
) -> ForgeResult:
    """Second a motion"""
    try:
        success = meeting_state.second_motion(motion_id, seconder)
        
        if not success:
            return ForgeResult(
                success=False,
                errors=["Motion cannot be seconded (may not exist, not require second, or already seconded)"]
            )
        
        return ForgeResult(
            success=True,
            data={
                "motion_id": motion_id,
                "status": "seconded",
                "next_step": "debate" if debatable else "vote"
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_vote_record_execute(
    motion_id: str,
    vote_method: str,
    yes_count: int,
    no_count: int,
    vote_result: str,
    abstain_count: Optional[int] = None,
) -> ForgeResult:
    """Record a vote on a motion"""
    try:
        # Validate vote method
        if not validate_vote_method(vote_method):
            return ForgeResult(
                success=False,
                errors=[f"Invalid vote method: {vote_method}"]
            )
        
        # Record the vote
        result = meeting_state.record_vote(
            motion_id=motion_id,
            yes_count=yes_count,
            no_count=no_count,
            abstain_count=abstain_count or 0,
            vote_method=vote_method
        )
        
        return ForgeResult(
            success=True,
            data={
                "motion_id": motion_id,
                "result": result,
                "yes": yes_count,
                "no": no_count,
                "abstain": abstain_count or 0
            }
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_point_of_order_raise_execute(
    member: str,
    issue: str,
    ruling: Optional[str] = None,
    appealed: Optional[bool] = None,
) -> ForgeResult:
    """Raise a point of order"""
    try:
        # Record the point of order
        point_data = {
            "member": member,
            "issue": issue,
            "timestamp": datetime.datetime.now().isoformat()
        }
        
        # Chair makes ruling if provided
        if ruling:
            point_data["ruling"] = ruling
            
        # Handle appeal if applicable
        if appealed is not None:
            point_data["appealed"] = appealed
            if appealed:
                # An appeal would create a new motion
                appeal_motion_id = f"appeal-{datetime.datetime.now().timestamp()}"
                meeting_state.add_motion(
                    motion_id=appeal_motion_id,
                    motion_type="incidental",
                    text=f"Appeal the ruling of the chair regarding: {issue}",
                    mover=member,
                    requires_second=True,
                    debatable=True,
                    vote_required="majority"
                )
                point_data["appeal_motion_id"] = appeal_motion_id
        
        return ForgeResult(
            success=True,
            data=point_data
        )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])

def roberts_recognition_request_execute(
    member: str,
    purpose: str,
    granted: bool,
    queue_position: Optional[int] = None,
) -> ForgeResult:
    """Request recognition to speak"""
    try:
        if granted:
            # Member is recognized immediately
            return ForgeResult(
                success=True,
                data={
                    "member": member,
                    "purpose": purpose,
                    "status": "recognized",
                    "may_proceed": True
                }
            )
        else:
            # Add to speaking queue
            position = meeting_state.add_to_speaking_queue(member, purpose)
            return ForgeResult(
                success=True,
                data={
                    "member": member,
                    "purpose": purpose,
                    "status": "queued",
                    "queue_position": position
                }
            )
        
    except Exception as e:
        return ForgeResult(success=False, errors=[str(e)])
