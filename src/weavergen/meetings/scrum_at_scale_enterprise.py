#!/usr/bin/env python3
"""
Enterprise Scrum at Scale implementation with full SAS framework.
All agents communicate via OpenTelemetry spans.
Models are generated by Weaver Forge from semantic conventions.
"""

import asyncio
import random
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Set
from enum import Enum
import json

from opentelemetry import trace, context
from opentelemetry.trace import Status, StatusCode
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.resources import Resource
from opentelemetry.sdk.trace.export import ConsoleSpanExporter, BatchSpanProcessor

# Import OTel communication from our implementation
import sys
import os
sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
from otel.communication import OTelCommunicationBus, OTelMessage, MessageType, Priority

# Setup tracing
resource = Resource.create({
    "service.name": "scrum-at-scale-enterprise",
    "service.version": "1.0.0",
    "sas.enterprise": "true",
    "sas.scale": "enterprise"
})

provider = TracerProvider(resource=resource)
processor = BatchSpanProcessor(ConsoleSpanExporter())
provider.add_span_processor(processor)
trace.set_tracer_provider(provider)
tracer = trace.get_tracer(__name__)

class SASMessageType(str, Enum):
    """Scrum at Scale specific message types"""
    # EAT Messages
    STRATEGIC_INITIATIVE = "strategic_initiative"
    TRANSFORMATION_UPDATE = "transformation_update"
    IMPEDIMENT_ESCALATION = "impediment_escalation"
    
    # EMS Messages
    PORTFOLIO_ALIGNMENT = "portfolio_alignment"
    RELEASE_COORDINATION = "release_coordination"
    BACKLOG_REFINEMENT = "backlog_refinement"
    
    # SoS Messages
    TEAM_SYNC = "team_sync"
    DEPENDENCY_ALERT = "dependency_alert"
    VELOCITY_REPORT = "velocity_report"
    
    # Release Train
    PI_PLANNING = "pi_planning"
    CONFIDENCE_VOTE = "confidence_vote"
    OBJECTIVES_UPDATE = "objectives_update"

class EnterpriseAgent:
    """Base class for all Scrum at Scale agents"""
    
    def __init__(self, agent_id: str, name: str, role: str, level: str):
        self.agent_id = agent_id
        self.name = name
        self.role = role
        self.level = level  # team, sos, eat, ems
        self.bus = None
        self.active = True
        
    def connect_to_bus(self, bus: OTelCommunicationBus):
        """Connect agent to communication bus"""
        self.bus = bus
        bus.register_agent(self.agent_id)
        bus.subscribe(self.agent_id, self.handle_message)
        
    async def handle_message(self, message: OTelMessage):
        """Handle incoming OTel message - override in subclasses"""
        pass
        
    async def send_span_message(self, recipient: str, msg_type: str, content: Dict[str, Any], priority: Priority = Priority.NORMAL):
        """Send message via OTel span"""
        if not self.bus:
            return
            
        with tracer.start_as_current_span(f"{self.name}.{msg_type}") as span:
            # Set all message attributes on the span
            span.set_attribute("agent.id", self.agent_id)
            span.set_attribute("agent.name", self.name)
            span.set_attribute("agent.role", self.role)
            span.set_attribute("agent.level", self.level)
            span.set_attribute("message.recipient", recipient)
            span.set_attribute("message.type", msg_type)
            span.set_attribute("message.content", json.dumps(content))
            span.set_attribute("message.priority", priority.value)
            
            # Add specific SAS attributes based on message type
            if self.level == "eat":
                span.set_attribute("sas.eat.executives_present", content.get("executives_present", 0))
            elif self.level == "ems":
                span.set_attribute("sas.ems.product_owners_count", content.get("po_count", 0))
            elif self.level == "sos":
                span.set_attribute("sas.sos.teams_count", content.get("teams_count", 0))
                
            # Send via bus for routing
            await self.bus.send_message(
                sender_id=self.agent_id,
                receiver_id=recipient,
                message_type=MessageType.NOTIFICATION,
                content=content,
                priority=priority,
                metadata={"sas_type": msg_type, "level": self.level}
            )

class ExecutiveActionTeam(EnterpriseAgent):
    """EAT - Enterprise leadership and transformation"""
    
    def __init__(self):
        super().__init__(
            agent_id="eat-001",
            name="Executive Action Team",
            role="enterprise_leadership",
            level="eat"
        )
        self.executives = [
            "CEO", "CTO", "CPO", "CFO", "COO", "CMO", "CHRO"
        ]
        self.strategic_priorities = [
            "digital_transformation",
            "market_expansion", 
            "operational_excellence",
            "customer_experience"
        ]
        
    async def handle_message(self, message: OTelMessage):
        """Handle escalated impediments and strategic decisions"""
        if message.metadata.get("sas_type") == "IMPEDIMENT_ESCALATION":
            await self.resolve_impediment(message.content)
        elif message.metadata.get("sas_type") == "TRANSFORMATION_UPDATE":
            await self.review_transformation_progress(message.content)
            
    async def resolve_impediment(self, impediment: Dict[str, Any]):
        """Resolve enterprise-level impediments"""
        with tracer.start_as_current_span("sas.eat.impediment_resolution") as span:
            span.set_attribute("sas.impediment.id", impediment.get("id"))
            span.set_attribute("sas.impediment.severity", impediment.get("severity", "high"))
            span.set_attribute("sas.impediment.teams_affected", impediment.get("teams_affected", 0))
            span.set_attribute("sas.impediment.cost_of_delay", impediment.get("cost_of_delay", 0))
            
            # Executive decision making
            resolution = {
                "impediment_id": impediment.get("id"),
                "resolution": "approved",
                "action": "allocate_resources",
                "budget_approved": impediment.get("cost_of_delay", 0) * 10,
                "executive_sponsor": random.choice(self.executives),
                "priority": "critical"
            }
            
            # Broadcast resolution
            await self.send_span_message(
                recipient="all",
                msg_type="IMPEDIMENT_RESOLUTION",
                content=resolution,
                priority=Priority.URGENT
            )
            
    async def conduct_strategic_review(self):
        """Conduct strategic review session"""
        with tracer.start_as_current_span("sas.eat") as span:
            span.set_attribute("sas.eat.type", "strategic")
            span.set_attribute("sas.eat.executives_present", len(self.executives))
            span.set_attribute("sas.eat.business_units", json.dumps(["engineering", "product", "sales", "marketing"]))
            
            strategic_update = {
                "priorities": self.strategic_priorities,
                "transformation_status": "on_track",
                "quarterly_objectives": [
                    "Scale to 500 teams",
                    "Reduce cycle time by 40%",
                    "Increase release frequency to daily"
                ],
                "investment_approved": 50000000  # $50M
            }
            
            await self.send_span_message(
                recipient="ems-001",
                msg_type="STRATEGIC_INITIATIVE",
                content=strategic_update,
                priority=Priority.HIGH
            )

class ExecutiveMetaScrum(EnterpriseAgent):
    """EMS - Product vision and portfolio alignment"""
    
    def __init__(self):
        super().__init__(
            agent_id="ems-001",
            name="Executive MetaScrum",
            role="chief_product_owner",
            level="ems"
        )
        self.chief_product_owner = "Sarah Chen"
        self.product_owners = []
        self.release_trains = ["platform", "mobile", "data", "infrastructure", "ai_ml"]
        self.portfolio_value = 1200.0  # $1.2B
        
    async def handle_message(self, message: OTelMessage):
        """Handle product strategy and portfolio messages"""
        if message.metadata.get("sas_type") == "STRATEGIC_INITIATIVE":
            await self.align_portfolio(message.content)
        elif message.metadata.get("sas_type") == "BACKLOG_REFINEMENT":
            await self.refine_enterprise_backlog(message.content)
            
    async def align_portfolio(self, strategic_priorities: Dict[str, Any]):
        """Align product portfolio with strategic priorities"""
        with tracer.start_as_current_span("sas.ems") as span:
            span.set_attribute("sas.ems.chief_product_owner", self.chief_product_owner)
            span.set_attribute("sas.ems.product_owners_count", 45)  # POs across enterprise
            span.set_attribute("sas.ems.portfolio_value", self.portfolio_value)
            span.set_attribute("sas.ems.release_trains", json.dumps(self.release_trains))
            
            portfolio_alignment = {
                "strategic_priorities": strategic_priorities.get("priorities", []),
                "release_train_objectives": {
                    "platform": ["microservices_migration", "api_gateway"],
                    "mobile": ["flutter_adoption", "offline_first"],
                    "data": ["real_time_analytics", "ml_pipeline"],
                    "infrastructure": ["kubernetes_everywhere", "zero_downtime"],
                    "ai_ml": ["llm_integration", "predictive_analytics"]
                },
                "quarterly_releases": 5,
                "epics_prioritized": 127
            }
            
            # Coordinate with release trains
            for train in self.release_trains:
                await self.send_span_message(
                    recipient=f"rte-{train}",
                    msg_type="PORTFOLIO_ALIGNMENT",
                    content=portfolio_alignment,
                    priority=Priority.HIGH
                )

class ScrumOfScrums(EnterpriseAgent):
    """SoS - Team coordination at various levels"""
    
    def __init__(self, level: str, teams: List[str]):
        level_map = {
            "team": "Team-level SoS",
            "program": "Program-level SoS", 
            "portfolio": "Portfolio SoSoS"
        }
        super().__init__(
            agent_id=f"sos-{level}-001",
            name=level_map.get(level, "SoS"),
            role="scrum_of_scrums_master",
            level="sos"
        )
        self.sos_level = level
        self.teams = teams
        self.impediments = []
        self.dependencies = []
        
    async def conduct_sos_meeting(self):
        """Conduct Scrum of Scrums meeting"""
        with tracer.start_as_current_span("sas.sos") as span:
            span.set_attribute("sas.sos.level", self.sos_level)
            span.set_attribute("sas.sos.teams_count", len(self.teams))
            span.set_attribute("sas.sos.scrum_master_facilitator", self.name)
            
            # Collect status from teams
            team_updates = []
            total_velocity = 0
            impediments_count = 0
            
            for team in self.teams:
                velocity = random.randint(21, 55)
                total_velocity += velocity
                has_impediment = random.random() < 0.3
                
                update = {
                    "team": team,
                    "velocity": velocity,
                    "sprint_health": random.choice(["green", "yellow", "red"]),
                    "impediment": "infrastructure_delays" if has_impediment else None
                }
                team_updates.append(update)
                if has_impediment:
                    impediments_count += 1
                    
            span.set_attribute("sas.sos.impediments_raised", impediments_count)
            span.set_attribute("sas.sos.dependencies_identified", random.randint(5, 15))
            
            # Handle impediments
            if impediments_count > 3 and self.sos_level == "portfolio":
                # Escalate to EAT
                impediment = {
                    "id": f"imp-{datetime.now().timestamp()}",
                    "severity": "critical",
                    "teams_affected": impediments_count * 5,
                    "cost_of_delay": impediments_count * 50.0,
                    "description": "Multiple teams blocked by infrastructure"
                }
                
                await self.send_span_message(
                    recipient="eat-001",
                    msg_type="IMPEDIMENT_ESCALATION",
                    content=impediment,
                    priority=Priority.URGENT
                )

class ScrumTeam(EnterpriseAgent):
    """Individual Scrum team in the enterprise"""
    
    def __init__(self, team_id: str, team_name: str, release_train: str):
        super().__init__(
            agent_id=team_id,
            name=team_name,
            role="scrum_team",
            level="team"
        )
        self.release_train = release_train
        self.velocity = random.randint(21, 55)
        self.sprint_number = random.randint(100, 200)
        self.team_size = random.randint(5, 9)
        self.scrum_master = f"sm-{team_id}"
        self.product_owner = f"po-{team_id}"
        
    async def report_sprint_status(self):
        """Report sprint status via OTel span"""
        with tracer.start_as_current_span("sas.team") as span:
            span.set_attribute("sas.team.id", self.agent_id)
            span.set_attribute("sas.team.size", self.team_size)
            span.set_attribute("sas.team.velocity", self.velocity)
            span.set_attribute("sas.team.sprint_number", self.sprint_number)
            span.set_attribute("sas.team.release_train", self.release_train)
            
            status = {
                "team": self.name,
                "sprint": self.sprint_number,
                "velocity": self.velocity,
                "stories_completed": random.randint(5, 12),
                "sprint_goal_met": random.random() > 0.2,
                "impediments": []
            }
            
            # Report to SoS
            await self.send_span_message(
                recipient=f"sos-team-{self.release_train}",
                msg_type="TEAM_SYNC",
                content=status,
                priority=Priority.NORMAL
            )

class ReleaseTrainEngineer(EnterpriseAgent):
    """RTE - Coordinates release train"""
    
    def __init__(self, train_name: str):
        super().__init__(
            agent_id=f"rte-{train_name}",
            name=f"RTE {train_name.title()}",
            role="release_train_engineer",
            level="program"
        )
        self.train_name = train_name
        self.teams_count = random.randint(5, 15)
        self.pi_number = random.randint(10, 20)
        
    async def conduct_pi_planning(self):
        """Conduct Program Increment planning"""
        with tracer.start_as_current_span("sas.release_train") as span:
            span.set_attribute("sas.release_train.id", f"rt-{self.train_name}")
            span.set_attribute("sas.release_train.teams_count", self.teams_count)
            span.set_attribute("sas.release_train.pi_number", self.pi_number)
            span.set_attribute("sas.release_train.engineer", self.name)
            
            # Confidence vote
            confidence = round(random.uniform(3.0, 5.0), 1)
            span.set_attribute("sas.release_train.confidence_vote", confidence)
            
            pi_plan = {
                "release_train": self.train_name,
                "pi_number": self.pi_number,
                "objectives": [
                    f"Deliver {self.train_name} feature set",
                    "Improve performance by 30%",
                    "Zero critical defects"
                ],
                "confidence_vote": confidence,
                "risks": ["dependency_on_platform", "resource_constraints"]
            }
            
            await self.send_span_message(
                recipient="ems-001",
                msg_type="PI_PLANNING",
                content=pi_plan,
                priority=Priority.HIGH
            )

async def run_enterprise_scrum_at_scale():
    """Run full enterprise Scrum at Scale simulation"""
    
    # Initialize communication bus
    bus = OTelCommunicationBus()
    
    # Create enterprise hierarchy
    print("üè¢ Initializing Enterprise Scrum at Scale")
    print("=" * 60)
    
    # Executive Action Team
    eat = ExecutiveActionTeam()
    eat.connect_to_bus(bus)
    
    # Executive MetaScrum
    ems = ExecutiveMetaScrum()
    ems.connect_to_bus(bus)
    
    # Release trains and RTEs
    release_trains = ["platform", "mobile", "data", "infrastructure", "ai_ml"]
    rtes = []
    for train in release_trains:
        rte = ReleaseTrainEngineer(train)
        rte.connect_to_bus(bus)
        rtes.append(rte)
    
    # Create teams per release train
    all_teams = []
    sos_masters = {}
    
    for train in release_trains:
        teams_in_train = []
        team_count = random.randint(10, 25)
        
        for i in range(team_count):
            team = ScrumTeam(
                team_id=f"team-{train}-{i:03d}",
                team_name=f"Team {train.title()} {i+1}",
                release_train=train
            )
            team.connect_to_bus(bus)
            teams_in_train.append(team)
            all_teams.append(team)
        
        # Create SoS for this train
        sos = ScrumOfScrums("team", [t.agent_id for t in teams_in_train[:9]])
        sos.connect_to_bus(bus)
        sos_masters[train] = sos
    
    # Create program-level SoS
    program_sos = ScrumOfScrums("program", list(sos_masters.keys()))
    program_sos.connect_to_bus(bus)
    
    # Create portfolio-level SoSoS
    portfolio_sos = ScrumOfScrums("portfolio", ["program-sos-001"])
    portfolio_sos.connect_to_bus(bus)
    
    print(f"‚úÖ Created enterprise structure:")
    print(f"   - 1 Executive Action Team (EAT)")
    print(f"   - 1 Executive MetaScrum (EMS)")
    print(f"   - {len(release_trains)} Release Trains")
    print(f"   - {len(all_teams)} Scrum Teams")
    print(f"   - {len(sos_masters)} Team-level SoS")
    print(f"   - 1 Program-level SoS")
    print(f"   - 1 Portfolio-level SoSoS")
    print()
    
    # Run enterprise ceremonies
    print("üöÄ Running Enterprise Ceremonies via OTel Communication")
    print("=" * 60)
    
    # 1. EAT Strategic Review
    print("\nüìä Executive Action Team Strategic Review")
    await eat.conduct_strategic_review()
    await asyncio.sleep(1)
    
    # 2. EMS Portfolio Alignment
    print("\nüìã Executive MetaScrum Portfolio Alignment")
    await asyncio.sleep(1)
    
    # 3. PI Planning for all trains
    print("\nüöÇ Program Increment Planning")
    for rte in rtes:
        await rte.conduct_pi_planning()
        await asyncio.sleep(0.5)
    
    # 4. Team Sprint Updates
    print("\nüë• Team Sprint Status Reports")
    sample_teams = random.sample(all_teams, min(10, len(all_teams)))
    for team in sample_teams:
        await team.report_sprint_status()
        await asyncio.sleep(0.2)
    
    # 5. SoS Meetings at all levels
    print("\nüîÑ Scrum of Scrums Coordination")
    for sos in sos_masters.values():
        await sos.conduct_sos_meeting()
        await asyncio.sleep(0.5)
    
    await program_sos.conduct_sos_meeting()
    await asyncio.sleep(1)
    
    await portfolio_sos.conduct_sos_meeting()
    await asyncio.sleep(1)
    
    # Show metrics
    print("\nüìà Enterprise Metrics")
    print("=" * 60)
    
    with tracer.start_as_current_span("sas.metrics") as span:
        total_velocity = sum(team.velocity for team in all_teams)
        avg_velocity = total_velocity / len(all_teams) if all_teams else 0
        
        span.set_attribute("sas.metrics.total_teams", len(all_teams))
        span.set_attribute("sas.metrics.total_people", len(all_teams) * 7)
        span.set_attribute("sas.metrics.release_trains", len(release_trains))
        span.set_attribute("sas.metrics.transformation_maturity", "performing")
        span.set_attribute("sas.metrics.cycle_time_days", 7.5)
        span.set_attribute("sas.metrics.release_frequency_days", 14.0)
        
        print(f"Total Teams: {len(all_teams)}")
        print(f"Total People: {len(all_teams) * 7}")
        print(f"Release Trains: {len(release_trains)}")
        print(f"Total Velocity: {total_velocity} story points/sprint")
        print(f"Average Team Velocity: {avg_velocity:.1f} story points/sprint")
        print(f"Transformation Maturity: Performing")
        print(f"Average Cycle Time: 7.5 days")
        print(f"Release Frequency: Every 14 days")
    
    print("\n‚úÖ Enterprise Scrum at Scale ceremony complete!")
    print("üìä All communication conducted through OpenTelemetry spans")
    
    # Show communication summary
    stats = bus.get_stats()
    print(f"\nüì° Communication Statistics:")
    print(f"   - Active Agents: {stats['active_agents']}")
    print(f"   - Total Messages: {stats['total_messages']}")
    print(f"   - Message Types: {stats['message_types']}")

if __name__ == "__main__":
    asyncio.run(run_enterprise_scrum_at_scale())