# Generated by Weaver Forge - Contracts Layer
# Contract definitions using icontract for runtime validation
# DO NOT EDIT - Generated from semantic conventions

import icontract
from typing import Optional, List, Any
from pathlib import Path

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")

# Precondition validators

def valid_file_path(path: str) -> bool:
    """Check if file path is valid (parent directory exists)"""
    return Path(path).parent.exists() or not Path(path).parent.as_posix()

def valid_semantic_path(path: str) -> bool:
    """Check if semantic file exists and is readable"""
    return Path(path).exists() and Path(path).suffix in ['.yaml', '.yml']

def valid_directory_path(path: str) -> bool:
    """Check if directory path is valid"""
    try:
        Path(path).mkdir(parents=True, exist_ok=True)
        return True
    except Exception:
        return False

def valid_language(language: str) -> bool:
    """Check if target language is supported"""
    return language in ['python', 'go', 'rust', 'java', 'typescript']

def valid_model(model: str) -> bool:
    """Check if LLM model is supported"""
    return model in ['llama3.2', 'gpt-4', 'mistral', 'codellama']

def valid_version(version: str) -> bool:
    """Check if version string is valid (x.y.z format)"""
    parts = version.split('.')
    return len(parts) == 3 and all(p.isdigit() for p in parts)

# Postcondition validators

def file_was_created(path: str) -> bool:
    """Check if file was created successfully"""
    return Path(path).exists()

def files_were_generated(file_list: Optional[List[str]]) -> bool:
    """Check if all expected files were generated"""
    if not file_list:
        return False
    return all(Path(f).exists() for f in file_list)

# Contract decorators for operations


# Contracts for forge.semantic.generate
class ForgeSemanticGenerateContracts:
    """Contract definitions for forge.semantic.generate"""
    
    
    @staticmethod
    def require_input_description(input_description: str) -> bool:
        """Natural language description to convert to semantic convention - Required"""
        return isinstance(input_description, str) and len(input_description) > 0
    
    @staticmethod
    def require_output_path(output_path: str) -> bool:
        """Path where semantic YAML will be written - Required"""
        return isinstance(output_path, str) and len(output_path) > 0
    
    @staticmethod
    def require_llm_model(llm_model: str) -> bool:
        """LLM model identifier used for generation - Required"""
        return isinstance(llm_model, str) and len(llm_model) > 0
    
    
    @staticmethod
    def require_validation_status(validation_status: str) -> bool:
        """Weaver validation result - Required"""
        return isinstance(validation_status, str) and len(validation_status) > 0
    
    
    
    
    # Specific contracts for semantic generation
    preconditions = [
        icontract.require(lambda input_description: len(input_description) > 0, "Description cannot be empty"),
        icontract.require(lambda output_path: valid_file_path(output_path), "Output path must be valid"),
        icontract.require(lambda llm_model: valid_model(llm_model), "Model must be supported"),
    ]
    
    postconditions = [
        icontract.ensure(lambda result: hasattr(result, 'success'), "Result must have success attribute"),
        icontract.ensure(lambda output_path, result: not result.success or file_was_created(output_path), 
                        "Output file must exist on success"),
    ]
    


# Contracts for forge.code.generate
class ForgeCodeGenerateContracts:
    """Contract definitions for forge.code.generate"""
    
    
    @staticmethod
    def require_input_semantic_path(input_semantic_path: str) -> bool:
        """Path to semantic convention YAML file - Required"""
        return isinstance(input_semantic_path, str) and len(input_semantic_path) > 0
    
    @staticmethod
    def require_target_language(target_language: str) -> bool:
        """Target programming language for generation - Required"""
        return isinstance(target_language, str) and len(target_language) > 0
    
    @staticmethod
    def require_template_directory(template_directory: str) -> bool:
        """Directory containing Weaver templates - Required"""
        return isinstance(template_directory, str) and len(template_directory) > 0
    
    @staticmethod
    def require_output_directory(output_directory: str) -> bool:
        """Directory where generated code will be written - Required"""
        return isinstance(output_directory, str) and len(output_directory) > 0
    
    
    
    
    # Specific contracts for code generation
    preconditions = [
        icontract.require(lambda input_semantic_path: valid_semantic_path(input_semantic_path), 
                         "Semantic file must exist"),
        icontract.require(lambda target_language: valid_language(target_language), 
                         "Target language must be supported"),
        icontract.require(lambda template_directory: Path(template_directory).exists(), 
                         "Template directory must exist"),
    ]
    
    postconditions = [
        icontract.ensure(lambda result: hasattr(result, 'success'), "Result must have success attribute"),
        icontract.ensure(lambda result: not result.success or 'files_generated' in (result.data or {}), 
                        "Generated files must be listed on success"),
    ]
    


# Contracts for forge.self.improve
class ForgeSelfImproveContracts:
    """Contract definitions for forge.self.improve"""
    
    
    @staticmethod
    def require_current_version(current_version: str) -> bool:
        """Current version of Forge being improved - Required"""
        return isinstance(current_version, str) and len(current_version) > 0
    
    @staticmethod
    def require_improvements(improvements: List[str]) -> bool:
        """List of improvements being applied - Required"""
        return isinstance(improvements, list) and all(isinstance(i, str) for i in improvements)
    
    
    @staticmethod
    def require_target_version(target_version: str) -> bool:
        """Target version after improvements - Required"""
        return isinstance(target_version, str) and len(target_version) > 0
    
    
    
    # Specific contracts for self-improvement
    preconditions = [
        icontract.require(lambda current_version: valid_version(current_version), 
                         "Current version must be valid"),
        icontract.require(lambda target_version: valid_version(target_version), 
                         "Target version must be valid"),
        icontract.require(lambda improvements: len(improvements) > 0, 
                         "Must specify at least one improvement"),
    ]
    
    postconditions = [
        icontract.ensure(lambda result: hasattr(result, 'success'), "Result must have success attribute"),
        icontract.ensure(lambda result: not result.success or 'reference_depth' in (result.data or {}), 
                        "Reference depth must be tracked"),
    ]
    



# Apply contracts to operations
def apply_contracts(func, contract_class):
    """Apply all contracts from a contract class to a function"""
    if hasattr(contract_class, 'preconditions'):
        for pre in contract_class.preconditions:
            func = pre(func)
    
    if hasattr(contract_class, 'postconditions'):
        for post in contract_class.postconditions:
            func = post(func)
    
    return func