# Generated by Weaver Forge - Commands Layer
# This layer provides thin interface wrappers with automatic telemetry
# DO NOT EDIT - This file is regenerated from semantic conventions

from opentelemetry import trace
from opentelemetry import metrics
from typing import Optional, Dict, Any, List
import functools
from dataclasses import dataclass

# Initialize telemetry
tracer = trace.get_tracer("weaver_forge")
meter = metrics.get_meter("weaver_forge")

# Metrics
operation_counter = meter.create_counter(
    "forge_operations_total",
    description="Total number of Forge operations",
    unit="1"
)

operation_duration = meter.create_histogram(
    "forge_operation_duration_seconds", 
    description="Duration of Forge operations",
    unit="s"
)

@dataclass
class ForgeResult:
    """Standard result type for Forge operations"""
    success: bool
    data: Optional[Any] = None
    errors: Optional[List[str]] = None

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    # Remove common prefixes
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")


def forge_semantic_generate(
    input_description: str,
    output_path: str,
    llm_model: str,
    validation_status: str,
    llm_temperature: Optional[float] = None,
    validation_errors: Optional[List[str]] = None,
) -> ForgeResult:
    """Generate semantic convention from natural language description
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        input_description: Natural language description to convert to semantic convention
        output_path: Path where semantic YAML will be written
        llm_model: LLM model identifier used for generation
        llm_temperature: Temperature parameter for LLM generation
        validation_status: Weaver validation result
        validation_errors: Validation error messages if any
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("forge.semantic.generate") as span:
        # Record span attributes
        
        span.set_attribute("forge.semantic.input.description", input_description)
        
        span.set_attribute("forge.semantic.output.path", output_path)
        
        span.set_attribute("forge.semantic.llm.model", llm_model)
        
        if llm_temperature is not None:
            span.set_attribute("forge.semantic.llm.temperature", llm_temperature)
        
        span.set_attribute("forge.semantic.validation.status", validation_status)
        
        if validation_errors is not None:
            span.set_attribute("forge.semantic.validation.errors", validation_errors)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "forge.semantic.generate"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import forge_semantic_generate_execute
            
            # Call the operation
            result = forge_semantic_generate_execute(
                input_description=input_description,
                output_path=output_path,
                llm_model=llm_model,
                validation_status=validation_status,
                llm_temperature=llm_temperature,
                validation_errors=validation_errors,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def forge_code_generate(
    input_semantic_path: str,
    target_language: str,
    template_directory: str,
    output_directory: str,
    files_generated: Optional[List[str]] = None,
) -> ForgeResult:
    """Generate code from semantic convention using Weaver
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        input_semantic_path: Path to semantic convention YAML file
        target_language: Target programming language for generation
        template_directory: Directory containing Weaver templates
        output_directory: Directory where generated code will be written
        files_generated: List of files generated
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("forge.code.generate") as span:
        # Record span attributes
        
        span.set_attribute("forge.code.input.semantic_path", input_semantic_path)
        
        span.set_attribute("forge.code.target.language", target_language)
        
        span.set_attribute("forge.code.template.directory", template_directory)
        
        span.set_attribute("forge.code.output.directory", output_directory)
        
        if files_generated is not None:
            span.set_attribute("forge.code.files.generated", files_generated)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "forge.code.generate"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import forge_code_generate_execute
            
            # Call the operation
            result = forge_code_generate_execute(
                input_semantic_path=input_semantic_path,
                target_language=target_language,
                template_directory=template_directory,
                output_directory=output_directory,
                files_generated=files_generated,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])


def forge_self_improve(
    current_version: str,
    improvements: List[str],
    target_version: str,
    reference_depth: Optional[int] = None,
) -> ForgeResult:
    """Self-referential improvement of Weaver Forge
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        current_version: Current version of Forge being improved
        improvements: List of improvements being applied
        reference_depth: Depth of self-reference (how many times Forge generated itself)
        target_version: Target version after improvements
        
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("forge.self.improve") as span:
        # Record span attributes
        
        span.set_attribute("forge.self.current.version", current_version)
        
        span.set_attribute("forge.self.improvements", improvements)
        
        if reference_depth is not None:
            span.set_attribute("forge.self.reference.depth", reference_depth)
        
        span.set_attribute("forge.self.target.version", target_version)
        
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "forge.self.improve"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import forge_self_improve_execute
            
            # Call the operation
            result = forge_self_improve_execute(
                current_version=current_version,
                improvements=improvements,
                target_version=target_version,
                reference_depth=reference_depth,
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])

