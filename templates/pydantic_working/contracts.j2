# Generated by Weaver Forge - Contracts Layer
# Contract definitions using icontract for runtime validation
# DO NOT EDIT - Generated from semantic conventions

import icontract
from typing import Optional, List, Any
from pathlib import Path

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")

# Precondition validators

def valid_file_path(path: str) -> bool:
    """Check if file path is valid (parent directory exists)"""
    return Path(path).parent.exists() or not Path(path).parent.as_posix()

def valid_semantic_path(path: str) -> bool:
    """Check if semantic file exists and is readable"""
    return Path(path).exists() and Path(path).suffix in ['.yaml', '.yml']

def valid_directory_path(path: str) -> bool:
    """Check if directory path is valid"""
    try:
        Path(path).mkdir(parents=True, exist_ok=True)
        return True
    except Exception:
        return False

def valid_language(language: str) -> bool:
    """Check if target language is supported"""
    return language in ['python', 'go', 'rust', 'java', 'typescript']

def valid_model(model: str) -> bool:
    """Check if LLM model is supported"""
    return model in ['llama3.2', 'gpt-4', 'mistral', 'codellama']

def valid_version(version: str) -> bool:
    """Check if version string is valid (x.y.z format)"""
    parts = version.split('.')
    return len(parts) == 3 and all(p.isdigit() for p in parts)

# Postcondition validators

def file_was_created(path: str) -> bool:
    """Check if file was created successfully"""
    return Path(path).exists()

def files_were_generated(file_list: Optional[List[str]]) -> bool:
    """Check if all expected files were generated"""
    if not file_list:
        return False
    return all(Path(f).exists() for f in file_list)

# Contract decorators for operations

{% for operation in ctx %}
# Contracts for {{ operation.id }}
class {{ operation.id | replace(".", "_") | title | replace("_", "") }}Contracts:
    """Contract definitions for {{ operation.id }}"""
    
    {% for attr in operation.attributes %}
    {%- if attr.requirement_level == "required" %}
    @staticmethod
    def require_{{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}: {% if "[]" in attr.type %}List[{{ attr.type | replace("[]", "") | map_text("python_types") }}]{% else %}{{ attr.type | map_text("python_types") }}{% endif %}) -> bool:
        """{{ attr.brief }} - Required"""
        {%- if attr.type == "string" and "path" in attr.name %}
        return isinstance({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}, str) and len({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}) > 0
        {%- elif attr.type == "string[]" %}
        return isinstance({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}, list) and all(isinstance(i, str) for i in {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }})
        {%- elif attr.type == "string" %}
        return isinstance({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}, str) and len({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}) > 0
        {%- elif attr.type == "int" %}
        return isinstance({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}, int) and {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }} >= 0
        {%- elif attr.type == "double" %}
        return isinstance({{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}, (int, float))
        {%- else %}
        return True  # Default validation
        {%- endif %}
    {%- endif %}
    {% endfor %}
    
    {% if operation.id == "forge.semantic.generate" %}
    # Specific contracts for semantic generation
    preconditions = [
        icontract.require(lambda input_description: len(input_description) > 0, "Description cannot be empty"),
        icontract.require(lambda output_path: valid_file_path(output_path), "Output path must be valid"),
        icontract.require(lambda llm_model: valid_model(llm_model), "Model must be supported"),
    ]
    
    postconditions = [
        icontract.ensure(lambda result: hasattr(result, 'success'), "Result must have success attribute"),
        icontract.ensure(lambda output_path, result: not result.success or file_was_created(output_path), 
                        "Output file must exist on success"),
    ]
    {% elif operation.id == "forge.code.generate" %}
    # Specific contracts for code generation
    preconditions = [
        icontract.require(lambda input_semantic_path: valid_semantic_path(input_semantic_path), 
                         "Semantic file must exist"),
        icontract.require(lambda target_language: valid_language(target_language), 
                         "Target language must be supported"),
        icontract.require(lambda template_directory: Path(template_directory).exists(), 
                         "Template directory must exist"),
    ]
    
    postconditions = [
        icontract.ensure(lambda result: hasattr(result, 'success'), "Result must have success attribute"),
        icontract.ensure(lambda result: not result.success or 'files_generated' in (result.data or {}), 
                        "Generated files must be listed on success"),
    ]
    {% elif operation.id == "forge.self.improve" %}
    # Specific contracts for self-improvement
    preconditions = [
        icontract.require(lambda current_version: valid_version(current_version), 
                         "Current version must be valid"),
        icontract.require(lambda target_version: valid_version(target_version), 
                         "Target version must be valid"),
        icontract.require(lambda improvements: len(improvements) > 0, 
                         "Must specify at least one improvement"),
    ]
    
    postconditions = [
        icontract.ensure(lambda result: hasattr(result, 'success'), "Result must have success attribute"),
        icontract.ensure(lambda result: not result.success or 'reference_depth' in (result.data or {}), 
                        "Reference depth must be tracked"),
    ]
    {% else %}
    # Default contracts
    preconditions = []
    postconditions = []
    {% endif %}

{% endfor %}

# Apply contracts to operations
def apply_contracts(func, contract_class):
    """Apply all contracts from a contract class to a function"""
    if hasattr(contract_class, 'preconditions'):
        for pre in contract_class.preconditions:
            func = pre(func)
    
    if hasattr(contract_class, 'postconditions'):
        for post in contract_class.postconditions:
            func = post(func)
    
    return func