# Generated by Weaver Forge - Commands Layer
# This layer provides thin interface wrappers with automatic telemetry
# DO NOT EDIT - This file is regenerated from semantic conventions

from opentelemetry import trace
from opentelemetry import metrics
from typing import Optional, Dict, Any, List
import functools
from dataclasses import dataclass

# Initialize telemetry
tracer = trace.get_tracer("weaver_forge")
meter = metrics.get_meter("weaver_forge")

# Metrics
operation_counter = meter.create_counter(
    "forge_operations_total",
    description="Total number of Forge operations",
    unit="1"
)

operation_duration = meter.create_histogram(
    "forge_operation_duration_seconds", 
    description="Duration of Forge operations",
    unit="s"
)

@dataclass
class ForgeResult:
    """Standard result type for Forge operations"""
    success: bool
    data: Optional[Any] = None
    errors: Optional[List[str]] = None

def _clean_attribute_name(attr_id: str) -> str:
    """Convert attribute ID to parameter name"""
    # Remove common prefixes
    name = attr_id
    for prefix in ["forge.semantic.", "forge.code.", "forge.self."]:
        if name.startswith(prefix):
            name = name[len(prefix):]
    return name.replace(".", "_")

{% for operation in ctx %}
def {{ operation.id | replace(".", "_") }}(
    {%- for attr in operation.attributes if attr.requirement_level == "required" %}
    {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}: {{ attr.type | map_text("python_types") }},
    {%- endfor %}
    {%- for attr in operation.attributes if attr.requirement_level != "required" %}
    {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}: Optional[{{ attr.type | map_text("python_types") }}] = None,
    {%- endfor %}
) -> ForgeResult:
    """{{ operation.brief }}
    
    This is a thin wrapper that:
    1. Records telemetry (traces and metrics)
    2. Validates inputs according to semantic conventions
    3. Delegates to the operations layer
    4. Returns standardized results
    
    Args:
        {% for attr in operation.attributes -%}
        {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}: {{ attr.brief }}
        {% endfor %}
    Returns:
        ForgeResult containing operation outcome
    """
    with tracer.start_span("{{ operation.id }}") as span:
        # Record span attributes
        {% for attr in operation.attributes %}
        {%- if attr.requirement_level == "required" %}
        span.set_attribute("{{ attr.name }}", {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }})
        {%- else %}
        if {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }} is not None:
            span.set_attribute("{{ attr.name }}", {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }})
        {%- endif %}
        {% endfor %}
        
        # Increment operation counter
        operation_counter.add(1, {"operation": "{{ operation.id }}"})
        
        try:
            # Import and delegate to operations layer
            from operations.forge import {{ operation.id | replace(".", "_") }}_execute
            
            # Call the operation
            result = {{ operation.id | replace(".", "_") }}_execute(
                {%- for attr in operation.attributes if attr.requirement_level == "required" %}
                {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}={{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }},
                {%- endfor %}
                {%- for attr in operation.attributes if attr.requirement_level != "required" %}
                {{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }}={{ attr.name | replace("forge.semantic.", "") | replace("forge.code.", "") | replace("forge.self.", "") | replace(".", "_") }},
                {%- endfor %}
            )
            
            # Record success
            span.set_status(trace.Status(trace.StatusCode.OK))
            if isinstance(result, ForgeResult):
                if result.success:
                    span.set_attribute("forge.result.success", True)
                else:
                    span.set_status(trace.Status(trace.StatusCode.ERROR))
                    span.set_attribute("forge.result.success", False)
                    if result.errors:
                        span.set_attribute("forge.result.errors", result.errors)
                return result
            else:
                # Wrap non-ForgeResult returns
                return ForgeResult(success=True, data=result)
                
        except Exception as e:
            # Record failure
            span.record_exception(e)
            span.set_status(trace.Status(trace.StatusCode.ERROR))
            span.set_attribute("forge.result.success", False)
            return ForgeResult(success=False, errors=[str(e)])

{% endfor %}