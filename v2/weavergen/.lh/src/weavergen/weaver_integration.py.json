{
    "sourceFile": "src/weavergen/weaver_integration.py",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 5,
            "patches": [
                {
                    "date": 1751480166016,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1751480280086,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -117,9 +117,9 @@\n                     f\"Weaver binary not found at {self.config.weaver_path}. \"\n                     \"Install with: cargo install weaver-forge\"\n                 ) from e\n     \n-    @semantic_span(\"weaver.registry.check\")\n+    @semantic_span(\"weaver\", \"registry.check\")\n     def check_registry(\n         self, \n         registry_path: Union[str, Path], \n         strict: bool = False\n"
                },
                {
                    "date": 1751480286343,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -222,9 +222,9 @@\n                     return_code=-1,\n                     stderr=str(e)\n                 )\n     \n-    @semantic_span(\"weaver.registry.generate\")\n+    @semantic_span(\"weaver\", \"registry.generate\")\n     def generate_code(\n         self,\n         registry_path: Union[str, Path],\n         target: WeaverTarget,\n"
                },
                {
                    "date": 1751480293084,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -360,9 +360,9 @@\n                     return_code=-1,\n                     stderr=str(e)\n                 )\n     \n-    @semantic_span(\"weaver.registry.stats\")\n+    @semantic_span(\"weaver\", \"registry.stats\")\n     def get_registry_stats(self, registry_path: Union[str, Path]) -> WeaverRegistryInfo:\n         \"\"\"Get statistics about a semantic convention registry.\"\"\"\n         registry_path = Path(registry_path)\n         \n"
                },
                {
                    "date": 1751480302321,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -425,9 +425,9 @@\n                     registry_path=registry_path,\n                     valid=False\n                 )\n     \n-    @semantic_span(\"weaver.registry.resolve\")\n+    @semantic_span(\"weaver\", \"registry.resolve\")\n     def resolve_registry(\n         self, \n         registry_path: Union[str, Path], \n         output_file: Optional[Path] = None\n"
                },
                {
                    "date": 1751480375866,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -97,9 +97,11 @@\n         self._validate_weaver_installation()\n     \n     def _validate_weaver_installation(self) -> None:\n         \"\"\"Validate that Weaver binary is available and working.\"\"\"\n-        with semantic_span(\"weaver.validate_installation\") as span:\n+        with tracer.start_as_current_span(\"weaver.validate_installation\") as span:\n+            span.set_attribute(\"component\", \"weaver\")\n+            span.set_attribute(\"operation\", \"validate_installation\")\n             try:\n                 result = subprocess.run(\n                     [str(self.config.weaver_path), \"--version\"],\n                     capture_output=True,\n"
                }
            ],
            "date": 1751480166016,
            "name": "Commit-0",
            "content": "\"\"\"Real Weaver Forge binary integration for WeaverGen v2.\"\"\"\n\nimport json\nimport logging\nimport subprocess\nimport tempfile\nfrom pathlib import Path\nfrom typing import Dict, List, Optional, Any, Union\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nfrom opentelemetry import trace\nfrom opentelemetry.trace import Status, StatusCode\nfrom pydantic import BaseModel, Field\n\nfrom .enhanced_instrumentation import semantic_span, add_span_event\n\nlogger = logging.getLogger(__name__)\ntracer = trace.get_tracer(__name__)\n\n\nclass WeaverTarget(str, Enum):\n    \"\"\"Available Weaver generation targets.\"\"\"\n    CODE_GEN_PYTHON = \"codegen_python\"\n    CODE_GEN_GO = \"codegen_go\"\n    CODE_GEN_RUST = \"codegen_rust\"\n    CODE_GEN_JAVA = \"codegen_java\"\n    CODE_GEN_TYPESCRIPT = \"codegen_typescript\"\n    CODE_GEN_DOTNET = \"codegen_dotnet\"\n    MARKDOWN = \"markdown\"\n    JSON_SCHEMA = \"json_schema\"\n    POLICY = \"policy\"\n\n\nclass WeaverDiagnosticFormat(str, Enum):\n    \"\"\"Available diagnostic output formats.\"\"\"\n    ANSI = \"ansi\"\n    JSON = \"json\"\n    GH_WORKFLOW_COMMAND = \"gh_workflow_command\"\n\n\n@dataclass\nclass WeaverConfig:\n    \"\"\"Configuration for Weaver operations.\"\"\"\n    weaver_path: Path = Path(\"weaver\")\n    templates_dir: Path = Path(\"templates\")\n    output_dir: Path = Path(\"output\")\n    diagnostic_format: WeaverDiagnosticFormat = WeaverDiagnosticFormat.ANSI\n    follow_symlinks: bool = False\n    include_unreferenced: bool = False\n    future_validation: bool = True\n    debug_level: int = 0\n    quiet: bool = False\n\n\nclass WeaverValidationResult(BaseModel):\n    \"\"\"Result of Weaver validation.\"\"\"\n    valid: bool\n    errors: List[str] = Field(default_factory=list)\n    warnings: List[str] = Field(default_factory=list)\n    diagnostics: List[Dict[str, Any]] = Field(default_factory=list)\n    return_code: int\n    stdout: str = \"\"\n    stderr: str = \"\"\n\n\nclass WeaverGenerationResult(BaseModel):\n    \"\"\"Result of Weaver code generation.\"\"\"\n    success: bool\n    output_dir: Path\n    generated_files: List[str] = Field(default_factory=list)\n    template_used: str = \"\"\n    parameters: Dict[str, Any] = Field(default_factory=dict)\n    return_code: int\n    stdout: str = \"\"\n    stderr: str = \"\"\n    diagnostics: List[Dict[str, Any]] = Field(default_factory=list)\n\n\nclass WeaverRegistryInfo(BaseModel):\n    \"\"\"Information about a Weaver registry.\"\"\"\n    registry_path: Path\n    valid: bool\n    stats: Dict[str, Any] = Field(default_factory=dict)\n    groups_count: int = 0\n    attributes_count: int = 0\n    metrics_count: int = 0\n    spans_count: int = 0\n    resources_count: int = 0\n\n\nclass WeaverIntegration:\n    \"\"\"Real Weaver Forge binary integration.\"\"\"\n    \n    def __init__(self, config: Optional[WeaverConfig] = None):\n        self.config = config or WeaverConfig()\n        self._validate_weaver_installation()\n    \n    def _validate_weaver_installation(self) -> None:\n        \"\"\"Validate that Weaver binary is available and working.\"\"\"\n        with semantic_span(\"weaver.validate_installation\") as span:\n            try:\n                result = subprocess.run(\n                    [str(self.config.weaver_path), \"--version\"],\n                    capture_output=True,\n                    text=True,\n                    check=True\n                )\n                version = result.stdout.strip()\n                span.set_attribute(\"weaver.version\", version)\n                logger.info(f\"Weaver {version} found and working\")\n                \n            except (subprocess.CalledProcessError, FileNotFoundError) as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, \"Weaver not found\"))\n                raise RuntimeError(\n                    f\"Weaver binary not found at {self.config.weaver_path}. \"\n                    \"Install with: cargo install weaver-forge\"\n                ) from e\n    \n    @semantic_span(\"weaver.registry.check\")\n    def check_registry(\n        self, \n        registry_path: Union[str, Path], \n        strict: bool = False\n    ) -> WeaverValidationResult:\n        \"\"\"Validate a semantic convention registry using Weaver.\"\"\"\n        registry_path = Path(registry_path)\n        \n        with tracer.start_as_current_span(\"weaver.registry.check\") as span:\n            span.set_attribute(\"registry_path\", str(registry_path))\n            span.set_attribute(\"strict\", strict)\n            \n            # Build command\n            cmd = [\n                str(self.config.weaver_path), \"registry\", \"check\",\n                \"-r\", str(registry_path)\n            ]\n            \n            if strict:\n                cmd.append(\"--future\")\n            \n            if self.config.debug_level > 0:\n                cmd.extend([\"--debug\"] * self.config.debug_level)\n            \n            if self.config.quiet:\n                cmd.append(\"--quiet\")\n            \n            add_span_event(\"weaver.command.start\", {\"command\": \" \".join(cmd)})\n            \n            try:\n                # Execute Weaver command\n                result = subprocess.run(\n                    cmd,\n                    capture_output=True,\n                    text=True,\n                    timeout=300  # 5 minute timeout\n                )\n                \n                span.set_attribute(\"return_code\", result.returncode)\n                span.set_attribute(\"stdout_length\", len(result.stdout))\n                span.set_attribute(\"stderr_length\", len(result.stderr))\n                \n                # Parse diagnostics if available\n                diagnostics = self._parse_diagnostics(result.stderr)\n                \n                # Determine validation result\n                valid = result.returncode == 0\n                errors = []\n                warnings = []\n                \n                if not valid:\n                    # Parse errors from stderr\n                    for line in result.stderr.split('\\n'):\n                        line = line.strip()\n                        if line and ('error' in line.lower() or 'failed' in line.lower()):\n                            errors.append(line)\n                        elif line and 'warning' in line.lower():\n                            warnings.append(line)\n                \n                # If no explicit errors found but return code is non-zero\n                if not valid and not errors:\n                    errors = [f\"Weaver validation failed with return code {result.returncode}\"]\n                \n                add_span_event(\"weaver.command.complete\", {\n                    \"valid\": valid,\n                    \"error_count\": len(errors),\n                    \"warning_count\": len(warnings)\n                })\n                \n                if valid:\n                    span.set_status(Status(StatusCode.OK))\n                else:\n                    span.set_status(Status(StatusCode.ERROR, f\"Validation failed: {len(errors)} errors\"))\n                \n                return WeaverValidationResult(\n                    valid=valid,\n                    errors=errors,\n                    warnings=warnings,\n                    diagnostics=diagnostics,\n                    return_code=result.returncode,\n                    stdout=result.stdout,\n                    stderr=result.stderr\n                )\n                \n            except subprocess.TimeoutExpired as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, \"Command timed out\"))\n                return WeaverValidationResult(\n                    valid=False,\n                    errors=[f\"Weaver command timed out after 300 seconds\"],\n                    return_code=-1,\n                    stderr=\"Command timed out\"\n                )\n            \n            except Exception as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, str(e)))\n                return WeaverValidationResult(\n                    valid=False,\n                    errors=[f\"Weaver command failed: {e}\"],\n                    return_code=-1,\n                    stderr=str(e)\n                )\n    \n    @semantic_span(\"weaver.registry.generate\")\n    def generate_code(\n        self,\n        registry_path: Union[str, Path],\n        target: WeaverTarget,\n        output_dir: Optional[Path] = None,\n        templates_dir: Optional[Path] = None,\n        parameters: Optional[Dict[str, Any]] = None,\n        policies: Optional[List[Path]] = None,\n        skip_policies: bool = False\n    ) -> WeaverGenerationResult:\n        \"\"\"Generate code from semantic conventions using Weaver.\"\"\"\n        registry_path = Path(registry_path)\n        output_dir = output_dir or self.config.output_dir\n        templates_dir = templates_dir or self.config.templates_dir\n        parameters = parameters or {}\n        \n        with tracer.start_as_current_span(\"weaver.registry.generate\") as span:\n            span.set_attribute(\"registry_path\", str(registry_path))\n            span.set_attribute(\"target\", target.value)\n            span.set_attribute(\"output_dir\", str(output_dir))\n            span.set_attribute(\"templates_dir\", str(templates_dir))\n            \n            # Ensure output directory exists\n            output_dir.mkdir(parents=True, exist_ok=True)\n            \n            # Build command\n            cmd = [\n                str(self.config.weaver_path), \"registry\", \"generate\",\n                \"-r\", str(registry_path),\n                \"-t\", str(templates_dir),\n                target.value,\n                str(output_dir)\n            ]\n            \n            # Add parameters\n            for key, value in parameters.items():\n                cmd.extend([\"-D\", f\"{key}={value}\"])\n            \n            # Add policies\n            if policies and not skip_policies:\n                for policy in policies:\n                    cmd.extend([\"-p\", str(policy)])\n            \n            if skip_policies:\n                cmd.append(\"--skip-policies\")\n            \n            if self.config.follow_symlinks:\n                cmd.append(\"--follow-symlinks\")\n            \n            if self.config.include_unreferenced:\n                cmd.append(\"--include-unreferenced\")\n            \n            if self.config.future_validation:\n                cmd.append(\"--future\")\n            \n            if self.config.debug_level > 0:\n                cmd.extend([\"--debug\"] * self.config.debug_level)\n            \n            if self.config.quiet:\n                cmd.append(\"--quiet\")\n            \n            add_span_event(\"weaver.command.start\", {\"command\": \" \".join(cmd)})\n            \n            try:\n                # Execute Weaver command\n                result = subprocess.run(\n                    cmd,\n                    capture_output=True,\n                    text=True,\n                    timeout=600  # 10 minute timeout for generation\n                )\n                \n                span.set_attribute(\"return_code\", result.returncode)\n                span.set_attribute(\"stdout_length\", len(result.stdout))\n                span.set_attribute(\"stderr_length\", len(result.stderr))\n                \n                # Parse diagnostics\n                diagnostics = self._parse_diagnostics(result.stderr)\n                \n                # Determine success\n                success = result.returncode == 0\n                \n                # Get generated files\n                generated_files = []\n                if success and output_dir.exists():\n                    generated_files = [\n                        str(f.relative_to(output_dir))\n                        for f in output_dir.rglob(\"*\")\n                        if f.is_file()\n                    ]\n                \n                add_span_event(\"weaver.command.complete\", {\n                    \"success\": success,\n                    \"files_generated\": len(generated_files)\n                })\n                \n                if success:\n                    span.set_status(Status(StatusCode.OK))\n                else:\n                    span.set_status(Status(StatusCode.ERROR, f\"Generation failed: {result.returncode}\"))\n                \n                return WeaverGenerationResult(\n                    success=success,\n                    output_dir=output_dir,\n                    generated_files=generated_files,\n                    template_used=target.value,\n                    parameters=parameters,\n                    return_code=result.returncode,\n                    stdout=result.stdout,\n                    stderr=result.stderr,\n                    diagnostics=diagnostics\n                )\n                \n            except subprocess.TimeoutExpired as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, \"Command timed out\"))\n                return WeaverGenerationResult(\n                    success=False,\n                    output_dir=output_dir,\n                    template_used=target.value,\n                    parameters=parameters,\n                    return_code=-1,\n                    stderr=\"Command timed out\"\n                )\n            \n            except Exception as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, str(e)))\n                return WeaverGenerationResult(\n                    success=False,\n                    output_dir=output_dir,\n                    template_used=target.value,\n                    parameters=parameters,\n                    return_code=-1,\n                    stderr=str(e)\n                )\n    \n    @semantic_span(\"weaver.registry.stats\")\n    def get_registry_stats(self, registry_path: Union[str, Path]) -> WeaverRegistryInfo:\n        \"\"\"Get statistics about a semantic convention registry.\"\"\"\n        registry_path = Path(registry_path)\n        \n        with tracer.start_as_current_span(\"weaver.registry.stats\") as span:\n            span.set_attribute(\"registry_path\", str(registry_path))\n            \n            # Build command\n            cmd = [\n                str(self.config.weaver_path), \"registry\", \"stats\",\n                \"-r\", str(registry_path)\n            ]\n            \n            if self.config.future_validation:\n                cmd.append(\"--future\")\n            \n            if self.config.debug_level > 0:\n                cmd.extend([\"--debug\"] * self.config.debug_level)\n            \n            try:\n                # Execute Weaver command\n                result = subprocess.run(\n                    cmd,\n                    capture_output=True,\n                    text=True,\n                    timeout=60\n                )\n                \n                span.set_attribute(\"return_code\", result.returncode)\n                \n                if result.returncode == 0:\n                    # Parse JSON output\n                    try:\n                        stats = json.loads(result.stdout)\n                        span.set_status(Status(StatusCode.OK))\n                        \n                        return WeaverRegistryInfo(\n                            registry_path=registry_path,\n                            valid=True,\n                            stats=stats,\n                            groups_count=stats.get(\"groups\", 0),\n                            attributes_count=stats.get(\"attributes\", 0),\n                            metrics_count=stats.get(\"metrics\", 0),\n                            spans_count=stats.get(\"spans\", 0),\n                            resources_count=stats.get(\"resources\", 0)\n                        )\n                    except json.JSONDecodeError:\n                        # Fallback to parsing text output\n                        return self._parse_stats_text(result.stdout, registry_path)\n                else:\n                    span.set_status(Status(StatusCode.ERROR, f\"Stats failed: {result.returncode}\"))\n                    return WeaverRegistryInfo(\n                        registry_path=registry_path,\n                        valid=False\n                    )\n                    \n            except Exception as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, str(e)))\n                return WeaverRegistryInfo(\n                    registry_path=registry_path,\n                    valid=False\n                )\n    \n    @semantic_span(\"weaver.registry.resolve\")\n    def resolve_registry(\n        self, \n        registry_path: Union[str, Path], \n        output_file: Optional[Path] = None\n    ) -> Path:\n        \"\"\"Resolve a semantic convention registry to a single file.\"\"\"\n        registry_path = Path(registry_path)\n        \n        with tracer.start_as_current_span(\"weaver.registry.resolve\") as span:\n            span.set_attribute(\"registry_path\", str(registry_path))\n            \n            if output_file is None:\n                output_file = Path(tempfile.mktemp(suffix=\".yaml\"))\n            \n            span.set_attribute(\"output_file\", str(output_file))\n            \n            # Build command\n            cmd = [\n                str(self.config.weaver_path), \"registry\", \"resolve\",\n                \"-r\", str(registry_path),\n                str(output_file)\n            ]\n            \n            if self.config.future_validation:\n                cmd.append(\"--future\")\n            \n            try:\n                # Execute Weaver command\n                result = subprocess.run(\n                    cmd,\n                    capture_output=True,\n                    text=True,\n                    timeout=120\n                )\n                \n                span.set_attribute(\"return_code\", result.returncode)\n                \n                if result.returncode == 0:\n                    span.set_status(Status(StatusCode.OK))\n                    return output_file\n                else:\n                    span.set_status(Status(StatusCode.ERROR, f\"Resolve failed: {result.returncode}\"))\n                    raise RuntimeError(f\"Failed to resolve registry: {result.stderr}\")\n                    \n            except Exception as e:\n                span.record_exception(e)\n                span.set_status(Status(StatusCode.ERROR, str(e)))\n                raise\n    \n    def _parse_diagnostics(self, stderr: str) -> List[Dict[str, Any]]:\n        \"\"\"Parse diagnostic messages from Weaver stderr output.\"\"\"\n        diagnostics = []\n        \n        for line in stderr.split('\\n'):\n            line = line.strip()\n            if not line:\n                continue\n            \n            # Try to parse as JSON diagnostic\n            if line.startswith('{') and line.endswith('}'):\n                try:\n                    diagnostic = json.loads(line)\n                    diagnostics.append(diagnostic)\n                except json.JSONDecodeError:\n                    pass\n            \n            # Parse ANSI diagnostic format\n            elif 'error' in line.lower() or 'warning' in line.lower():\n                diagnostics.append({\n                    \"type\": \"error\" if \"error\" in line.lower() else \"warning\",\n                    \"message\": line,\n                    \"raw\": line\n                })\n        \n        return diagnostics\n    \n    def _parse_stats_text(self, stdout: str, registry_path: Path) -> WeaverRegistryInfo:\n        \"\"\"Parse statistics from text output when JSON is not available.\"\"\"\n        stats = {}\n        groups_count = 0\n        attributes_count = 0\n        metrics_count = 0\n        spans_count = 0\n        resources_count = 0\n        \n        for line in stdout.split('\\n'):\n            line = line.strip()\n            if 'groups:' in line.lower():\n                try:\n                    groups_count = int(line.split(':')[1].strip())\n                except (IndexError, ValueError):\n                    pass\n            elif 'attributes:' in line.lower():\n                try:\n                    attributes_count = int(line.split(':')[1].strip())\n                except (IndexError, ValueError):\n                    pass\n            elif 'metrics:' in line.lower():\n                try:\n                    metrics_count = int(line.split(':')[1].strip())\n                except (IndexError, ValueError):\n                    pass\n            elif 'spans:' in line.lower():\n                try:\n                    spans_count = int(line.split(':')[1].strip())\n                except (IndexError, ValueError):\n                    pass\n            elif 'resources:' in line.lower():\n                try:\n                    resources_count = int(line.split(':')[1].strip())\n                except (IndexError, ValueError):\n                    pass\n        \n        return WeaverRegistryInfo(\n            registry_path=registry_path,\n            valid=True,\n            stats=stats,\n            groups_count=groups_count,\n            attributes_count=attributes_count,\n            metrics_count=metrics_count,\n            spans_count=spans_count,\n            resources_count=resources_count\n        )\n    \n    def get_available_targets(self) -> List[WeaverTarget]:\n        \"\"\"Get list of available Weaver generation targets.\"\"\"\n        return list(WeaverTarget)\n    \n    def get_weaver_version(self) -> str:\n        \"\"\"Get Weaver version.\"\"\"\n        try:\n            result = subprocess.run(\n                [str(self.config.weaver_path), \"--version\"],\n                capture_output=True,\n                text=True,\n                check=True\n            )\n            return result.stdout.strip()\n        except Exception:\n            return \"unknown\" "
        }
    ]
}